<?xml version="1.0" encoding="utf-8"?>
<namespace name="AmbientOS">
  <!-- universal aliasses -->
  <alias name="bool" alias="Boolean" />
  <alias name="sbyte" alias="Int8" />
  <alias name="byte" alias="UInt8" />
  <alias name="short" alias="Int16" />
  <alias name="ushort" alias="UInt16" />
  <alias name="int" alias="Int32" />
  <alias name="uint" alias="UInt32" />
  <alias name="long" alias="Int64" />
  <alias name="ulong" alias="UInt64" />
  <alias name="char" alias="Char" />
  <alias name="string" alias="String" />

  <!-- C# built-in types -->
  <type lang="C#" name="Boolean" code="bool" />
  <type lang="C#" name="Int8" code="sbyte" />
  <type lang="C#" name="UInt8" code="byte" />
  <type lang="C#" name="Int16" code="short" />
  <type lang="C#" name="UInt16" code="ushort" />
  <type lang="C#" name="Int32" code="int" />
  <type lang="C#" name="UInt32" code="uint" />
  <type lang="C#" name="Int64" code="long" />
  <type lang="C#" name="UInt64" code="ulong" />
  <type lang="C#" name="Char" code="char" />
  <type lang="C#" name="String" code="string" />
  <type lang="C#" name="Guid" code="Guid" />
  <type lang="C#" name="DateTime" code="DateTime" />
  <type lang="C#" name="Type" code="Type" />
  <type lang="C#" name="Array[T]" code="T[]" />
  <type lang="C#" name="Enumerable[T]" code="IEnumerable&lt;T&gt;" />
  <type lang="C#" name="Maybe[T]" code="T?" />

  <!-- C built-in types -->
  <type lang="C" name="UInt64" code="uint64_t" />

  <alias lang="C" name="String" alias="Array[Char]" />

  
  <!-- C# additional types -->
  <type lang="C#" name="DynamicSet[T]" code="DynamicSet&lt;T&gt;" />
  <type lang="C#" name="ObjRef" code="IObjectRef" />
  <type lang="C#" name="Context" code="Context" />
  <type lang="C#" name="Vector2D[T]" code="Vector2D&lt;T&gt;" />


  <namespace name="Environment">
    <summary>
      Contains interfaces related to the system itself, e.g applications, services and settings
    </summary>

    <type lang="C#" name="LogContext" code="LogContext" />
    <type lang="C#" name="Shell" code="IShell" />

    <interface name="Environment">
      <summary>
        Represents the environment in which an action is executed.
      </summary>
      <method name="GetTempFolder" ret="FileSystem.Folder">
        <summary>
          todo: rework this concept
          what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
          maybe this should be combined with access to other kinds of folders (application data, ...)
          and the thought seems to go a similar way with storing settings
        </summary>
      </method>
    </interface>

    <interface name="Application">
      <summary>
        Represents an application.
        todo: define this interface.
        consider: application name, associated actions, update, ...
      </summary>
      <method name="Load">
        <summary>
          Loads and initializes the application if neccessary.
        </summary>
        <param name="context" type="Context" />
      </method>
    </interface>

    <interface name="Action">
      <summary>
        Represents an action that can execute a verb on specific kinds of objects.
      </summary>
      <attribute name="verb" method="GetVerb" />
      <attribute name="input" method="GetInputTypeName" />
      <attribute name="output" method="GetOutputTypeName" />
      <method name="GetVerb" ret="string">
        <summary>
          Returns the verb that this action represents.
        </summary>
      </method>
      <method name="GetInputTypeName" ret="string">
        <summary>
          Indicates the name of the type that this action expects as an input.
        </summary>
      </method>
      <method name="GetInputType" ret="Type">
        <summary>
          Returns the type that this action expects as an input.
        </summary>
      </method>
      <method name="GetOutputTypeName" ret="string">
        <summary>
          Indicates the name of the type that this action returns as an output.
        </summary>
      </method>
      <method name="GetOutputType" ret="Type">
        <summary>
          Returns the type that this action returns as an output.
        </summary>
      </method>
      <method name="Invoke" ret="DynamicSet[ObjRef]">
        <summary>
          Excecutes this action on the specified object.
          Shall return the objects that are generated by this action if any.
          If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
        </summary>
        <param name="obj" type="ObjRef" summary="The object on which to execute the action" />
        <param name="context" type="Context" summary="The context in which to execute the action" />
      </method>
    </interface>
  </namespace>


  <namespace name="UI">
    <enum name="Level">
      <summary>
        Describes how hard to understand or use a specific option or feature is.
      </summary>
      <value name="Recommended" summary="This choice is easy to understand and recommended. Typically, out of multiple options, only one is the recommended one." />
      <value name="Easy" summary="This choice is easy to understand." />
      <value name="Escape" summary="This corresponds to a negative decision, such as No, Cancel" />
      <value name="Advanced" summary="This choice cannot be expected to be the right choice for a basic user. It will only be offered to advanced users." />
    </enum>

    <enum name="Severity">
      <summary>
        The severity of a message.
        Do not use high severities unneccessarily as not to annoy the user.
      </summary>
      <value name="Info" summary="The message is an information. Such a message usually disappears after some time or may not be shown at all." />
      <value name="Success" summary="Some action the user requested succeeded. Such a message usually disappears after some time or may not be shown at all. Examples: success message" />
      <value name="Warning" summary="Some action the user requested could not be started or something else happened that the active user should known about. Examples: battery low" />
      <value name="Error" summary="Some action the user requested could not be completed or something else happened that the active user should known about. Examples: service crashed" />
      <!--<value name="Internal" summary="There was an internal issue. This is usually not shown to normal users. Instead, it is either sent to the responsible system administrator(s) or logged. Example: bug in application" />-->
    </enum>

    <struct name="Text">
      <summary>
        Holds one or more localized strings that describe the same thing with different degrees of detail.
      </summary>
      <field name="Summary" type="string">
        <summary>
          This should be short, very easy to understand and not use any technical terms.
        </summary>
      </field>
      <field name="Details" type="string">
        <summary>
          A more detailed version of the message.
          Can be null.
        </summary>
      </field>
      <field name="Debug" type="string">
        <summary>
          This should include all technical details about the message, specifically for power users and developers.
          Can be null.
        </summary>
      </field>
    </struct>

    <struct name="Option">
      <summary>
        Represents a possible answer by the user to a question posed to the user.
      </summary>
      <field name="Text" type="Text" />
      <field name="Level" type="Level" />
    </struct>

    <enum name="ConsoleColor">
      <value name="DefaultForeground" />
      <value name="DefaultBackground" />
      <value name="Red" />
      <value name="Yellow" />
      <value name="Green" />
      <value name="White" />
      <value name="Gray" />
      <value name="DarkGray" />
      <value name="Black" />
    </enum>
    
    <enum name="Key">
      <summary>
        Represents a normal key (everything that is not an action key).
      </summary>
      <value name="Unknown" value="0" />
      <value name="ArrowUp" />
      <value name="ArrowDown" />
      <value name="ArrowLeft" />
      <value name="ArrowRight" />
      <value name="PageUp" />
      <value name="PageDown" />
      <value name="Home" />
      <value name="End" />
      <value name="Esc" />
      <value name="Enter" />
      <value name="Insert" />
      <value name="Tab" />
      <value name="Backspace" />
      <value name="Space" />
    </enum>

    <enum name="KeyModifiers">
      <summary>
        Represents one or multiple modifier keys.
      </summary>
      <value name="Control" value="0x1" />
      <value name="Alt" value="0x2" />
      <value name="Shift" value="0x4" />
    </enum>
    
    <struct name="KeyPress">
      <field name="Key" type="Key" summary="If Unknown, check the Char field." />
      <field name="Modifiers" type="KeyModifiers" />
      <field name="Char" type="Maybe[char]" summary="Holds the unicode char associated with the key press. Null if no unicode char can be assigned to the key press." />
    </struct>

    <interface name="Console">
      <method name="Write">
        <summary>
          Prints the specified text on the console starting at the current cursor position.
          The cursor is advanced to the location after the text.
          If a character is printed below the last line, the buffer is scrolled accordingly.
          This function shall accept \n as a new line character.
        </summary>
        <param name="text" type="string" />
        <param name="textColor" type="ConsoleColor" summary="The text color (this may be ignored by some implementations)." />
        <param name="backgroundColor" type="ConsoleColor" summary="The background color (this may be ignored by some implementations)." />
      </method>
      <method name="Read" ret="KeyPress">
        <summary>
          Waits for a single key stroke and returns the result.
          Modifier keys are not recognized on their own.
          The pressed key is not printed to the console.
        </summary>
      </method>
      <method name="Clear">
        <summary>
          Clears the visible console buffer.
        </summary>
        <param name="color" type="ConsoleColor" summary="The background color" />
      </method>
      <method name="GetDimensions" ret="Vector2D[int]">
        <summary>
          Returns the size of the console in chars.
        </summary>
      </method>
      <method name="GetCursorPosition" ret="Vector2D[int]">
        <summary>
          Returns the current cursor position.
        </summary>
      </method>
      <method name="SetCursorPosition">
        <summary>
          Sets the cursor position.
          (0, 0) denotes the top left corner of the buffer.
        </summary>
        <param name="position" type="Vector2D[int]" summary="The new cursor position" />
        <param name="visible" type="bool" summary="Indicates whether the cursor should be visible" />
      </method>
    </interface>
    
    <interface name="UI">
      <summary>
        A shell is the environment in which an action is executed.
        A shell may be a console, a graphical user interface, a speech based
        interface or anything else that allows for interaction with the user.

        Actually, let's refine that:
        A shell is just an environment for the action, that can be used by the action
        to interact with the platform. If, e.g. an action is executed in a console, that doesn't
        mean that the console is used for all user interaction. The job of figuring out the right mode of
        interaction is the job of the user experience service.
      </summary>
      <method name="PresentDialog" ret="long">
        <summary>
          Presents a message to the user and allows the user to select one out of a set of possible answers.
          Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
          If the shell makes the decision, it shall do so according to the following rules:
          If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
          If there is are recommended options, the first one shall be selected.
          If there is no recommended option, the first option shall be selected.
        </summary>
        <param name="message" type="Text" />
        <param name="options" type="Array[Option]" />
      </method>
      <method name="Notify">
        <summary>
          Notifies the user about something, e.g. a success or error message.
          Depending on the setting and severity, the message may disappear after some time or not be shown at all.
        </summary>
        <param name="message" type="Text" />
        <param name="severity" type="Severity" />
      </method>
    </interface>
  </namespace>
  

  <namespace name="FileSystem">
    <summary>
      Contains interfaces related to files, file systems and disks.
    </summary>

    <enum name="FileSystemFlags">
      <value name="Hidden" value="0x1" />
      <value name="SoftLink" value="0x2" />
      <value name="Sparse" value="0x4" />
      <value name="Compressed" value="0x8" />
      <value name="Encrypted" value="0x10" />
    </enum>

    <enum name="OpenMode" summary="Specifies the mode of creating or opening files or folders.">
      <value name="New" value="1" summary="Request the creation of a new file or folder. If a file or folder with the same name already exists, the create method shall throw an exception." />
      <value name="Existing" value="2" summary="Request an existing file or folder. If the specified file or folder does not exist, the create method shall throw an exception." />
      <value name="NewOrExisting" value="3" summary="The file or folder is only created if it doesn't already exist, otherwise the existing one is returned." />
    </enum>

    <enum name="DeleteMode" summary="Specifies the mode of file/folder deletion. If deletion is supported on a given object, at least the Permanent option must be supported.">
      <value name="Permanent" summary="The file or folder is deleted quickly and the allocated disk space becomes free. This cannot be undone. Choose this option for temporary files that contain no user data or if the user explicitly requests it." />
      <value name="Trash" summary="The file is moved to the trash associated with the containing file system and may automatically be deleted after some time period. Choose this option if the user requested the deletion." />
    </enum>

    <enum name="MergeMode" summary="Specifies the action that is taken if a conflict arises while copying.">
      <value name="Abort" value="0x0" summary="If a conflict arises, abort the operation" />
      <value name="Evict" value="0x1" summary="Override the file at the destination" />
      <value name="Skip" value="0x2" summary="Don't copy conflicting files" />
      <value name="Both" value="0x3" summary="Keep both files and rename the file being copied" />
      <value name="Newer" value="0x4" summary="Keep the file with the most recent modified time" />
      <value name="Older" value="0x5" summary="Keep the file with the oldest modified time" />
      <value name="Merge" value="0x8" summary="If the conflicting objects are folders, merge them recursively. This flag can be combined with any of the other options (except for Abort)." />
    </enum>

    <struct name="DiskInfo">
      <field name="ID" type="Guid">
        <summary>
          The ID reported by the hard disk.
          Be careful when using this, it could be modified and non-unique, especially for virtual disks.
        </summary>
      </field>
      <field name="Tracks" type="int">
        <summary>
          The total number of tracks on the disk.
          In most cases (i.e. for normal hard drives, SSDs, and most optical disks), this will be 1.
          There are however some CD's that have multiple tracks.
        </summary>
      </field>
      <field name="Sectors" type="long">
        <summary>
          The total number of sectors on one track of the disk.
        </summary>
      </field>
      <field name="MaxSectors" type="long">
        <summary>
          The maximum number of sectors the disk could be expanded to.
          For most real disks, this will be the same as the current sector count.
        </summary>
      </field>
      <field name="BytesPerSector" type="long">
        <summary>
          The number of bytes per sector.
          Most of the time, this will be 512, and sometimes 4096, but you should not rely on that assumption.
        </summary>
      </field>
    </struct>

    <struct name="VolumeInfo">
      <field name="ID" type="Guid">
        <summary>
          The ID of the volume. Volumes on a disk using the MBR partitioning scheme get an ID derived from the disk ID and volume offet.
          Be careful when using this, it could be modified and non-unique, especially for virtual disks.
        </summary>
      </field>
      <field name="Type" type="Guid">
        <summary>
          The type of the volume, as specified in the partition table.
          Zero if unknown. For legacy MBR partitions, only the last byte specifies the type and the rest is zero.
        </summary>
      </field>
      <field name="flags" type="FileSystemFlags" />
    </struct>

    <struct name="VolumeExtent">
      <field name="Track" type="int" summary="The track of the disk on which the extent resides. In most cases this is 0, since there's mostly only one track." />
      <field name="StartSector" type="long" summary="The absolute start sector of the extent on the underlying disk." />
      <field name="Sectors" type="long" summary="The total number of sectors in the extent." />
      <field name="MaxSectors" type="long" summary="The maximum number of sectors this extent could be expanded to. If there is no free space on disk following the extent, this is the same as the current sector count." />
      <field name="Disk" type="Disk" summary="The underlying disk." />
    </struct>

    <struct name="FileTimes">
      <summary>
        Contains different kinds of times associated with the file.
        All times should be in UTC.
        For reading, null values indicate that the particular value is not available.
        For writing, set the fields to null that shouldn't be updated.
      </summary>
      <field name="CreatedTime" type="Maybe[DateTime]">
        <summary>
          Time when the file or folder was created.
          AmbientOS file system drivers shall initialize this field automatically.
        </summary>
      </field>
      <field name="ModifiedTime" type="Maybe[DateTime]">
        <summary>
          Time when the file was modified.
          Semantics not clearly defined for folders.
          AmbientOS file system drivers shall update this field automatically.
        </summary>
      </field>
      <field name="ReadTime" type="Maybe[DateTime]">
        <summary>
          Time when the file was last read.
          AmbientOS file system drivers shall NOT update this field automatically, hence it is of limited value.
        </summary>
      </field>
    </struct>

    <struct name="NamingConventions">
      <field name="ForbiddenChars" type="Array[char]" summary="All characters that must not occur anywhere of a name." />
      <field name="ForbiddenLeadingChars" type="Array[char]" summary="All characters that must not occur at the beginning of a name." />
      <field name="ForbiddenTrailingChars" type="Array[char]" summary="All characters that must not occur at the end of a name." />
      <field name="ForbiddenNames" type="Array[string]" summary="All strings that must not be used as a file or folder name." />
      <field name="MaxNameLength" type="long" summary="The maximum number of chars in the name. Set to -1 to indicate no limit." />
      <field name="CaseSensitive" type="bool" summary="Indicates whether the file system uses case sensitive name comparision." />
    </struct>

    <interface name="Disk">
      <method name="GetInfo" ret="DiskInfo">
        <summary>
          Returns information about the disk.
        </summary>
      </method>
      <method name="SetSize" ret="long">
        <summary>
          Changes the number of sectors in the disk.
          This may be possible for virtual disks.
          This affects all tracks equally.
          Returns the actual size that was set. This may be different from the requested size if it's too large.
        </summary>
        <param name="sectorCount" type="long" summary="New size in bytes." />
      </method>
      <method name="Read">
        <summary>
          Reads the specified sectors.
          The method shall fail if the requested range is out of bounds.
        </summary>
        <param name="track" type="int" />
        <param name="offset" type="long" summary="The sector number (starting at 0)." />
        <param name="count" type="long" summary="The number of sectors to read." />
        <param name="buffer" type="Array[byte]" />
        <param name="bufferOffset" type="long" />
      </method>
      <method name="Write">
        <summary>
          Writes to the specified sectors.
          The method shall fail if the requested range is out of bounds.
        </summary>
        <param name="track" type="int" />
        <param name="offset" type="long" summary="The sector number (starting at 0)." />
        <param name="count" type="long" summary="The number of sectors to write." />
        <param name="buffer" type="Array[byte]" />
        <param name="bufferOffset" type="long" />
      </method>
      <method name="Flush">
        <summary>
          Flushes any cached write operations to this disk to the device.
          The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file shoud also be flushed.
          The method must not return until the changes are committed to non-volatile storage.
        </summary>
      </method>
    </interface>

    <interface name="Volume">
      <method name="GetInfo" ret="VolumeInfo">
        <summary>
          Returns information about the volume.
        </summary>
      </method>
      <method name="GetExtents" ret="Array[VolumeExtent]">
        <summary>
          Returns the extents that make up this volume.
          In most cases, the result contains a single element.
          The result may be incomplete, for instance if the volume is partially virtual.
        </summary>
      </method>
      <method name="GetSize" ret="long">
        <summary>
          Returns size of the volume in bytes.
        </summary>
      </method>
      <method name="SetSize" ret="long">
        <summary>
          Changes size of the volume.
          This may be possible on a virtual volume or if there is unused disk space following the last volume extent.
          Returns the actual size that was set. This may be different from the requested size if it's too large or not sector-aligned.
        </summary>
        <param name="size" type="long" summary="New size in bytes." />
      </method>
      <method name="Read">
        <summary>
          Reads data from the volume.
          The method shall fail if the requested range is out of bounds.
        </summary>
        <param name="offset" type="long" />
        <param name="count" type="long" />
        <param name="buffer" type="Array[byte]" />
        <param name="bufferOffset" type="long" />
      </method>
      <method name="Write">
        <summary>
          Writes data to the volume.
          The method shall fail if the requested range is out of bounds.
        </summary>
        <param name="offset" type="long" />
        <param name="count" type="long" />
        <param name="buffer" type="Array[byte]" />
        <param name="bufferOffset" type="long" />
      </method>
      <method name="Flush">
        <summary>
          Flushes any cached write operations to this volume to disk.
          The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
          The method must not return until the changes are committed to non-volatile storage.
        </summary>
      </method>
    </interface>

    <interface name="FileSystem">
      <summary>
        Exposes a file system.
      </summary>
      <method name="GetName" ret="string">
        <summary>
          Returns the human-readable volume name.
          Shall return null if there is no name available.
        </summary>
      </method>
      <method name="SetName">
        <summary>
          Sets the volume name.
        </summary>
        <param name="file" type="string" summary="The new volume name" />
      </method>
      <method name="GetNamingConventions" ret="NamingConventions">
        <summary>
          Returns the naming conventions for this file system.
        </summary>
      </method>
      <method name="GetRoot" ret="Folder">
        <summary>
          Returns the root folder of this file system.
        </summary>
      </method>
      <method name="GetTotalSpace" ret="Maybe[long]">
        <summary>
          Returns the total size of the volume in bytes.
          Shall return null if this is not applicable.
        </summary>
      </method>
      <method name="GetFreeSpace" ret="Maybe[long]">
        <summary>
          Returns the free space on the volume in bytes.
          Shall return null if this is not applicable.
        </summary>
      </method>
      <method name="GetFiles" ret="Enumerable[string]">
        <summary>
          Runs a search query on the file system and returns all matching files and folders.
          Search query examples (todo: decide on case sensitivity):
          abc.txt     returns all files with the name "abc.txt"
          *.txt       returns all files with the .txt extension (including the file named ".txt")
          *a*c*       returns all files that have "a" and "c" in their name in this order
          /abc.txt    returns all files named "abc.txt" in the root folder
          /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
          abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
          projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have

          todo: rethink this - implemantation probably too complicated
        </summary>
        <param name="query" type="string" summary="The query string (see remarks)." />
      </method>
      <method name="Move">
        <summary>
          Moves a file or folder within this file system.
        </summary>
        <param name="file" type="FileSystemObject" summary="The file or folder being moved. If this doesn't belong to this file system, the method shall fail." />
        <param name="destination" type="Folder" summary="The destination of the move operation. If this doesn't belong to this file system, the method shall fail." />
        <param name="newName" type="string" summary="The new name of the file or folder being moved." />
      </method>
      <method name="Copy" ret="FileSystemObject">
        <summary>
          Copies a file or folder within this file system.
          Returns the object at the destination.
        </summary>
        <param name="file" type="FileSystemObject" summary="The file or folder being copied. If this doesn't belong to this file system, the method shall fail." />
        <param name="destination" type="Folder" summary="The destination of the copy operation. If this doesn't belong to this file system, the method shall fail." />
        <param name="newName" type="string" summary="The new name of the file or folder being copied." />
        <param name="mode" type="MergeMode" summary="The behavior in case of conflicts" />
      </method>
    </interface>

    <interface name="FileSystemObject">
      <attribute name="name" method="GetName" />
      <method name="GetFileSystem" ret="FileSystem">
        <summary>
          Returns the file system that contains this file or folder.
          Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
        </summary>
      </method>
      <method name="GetPath" ret="string">
        <summary>
          todo: think about what we really want
          do we want a path that uniquely identifies the object value?
          relative to what? another object reference? the current kernel realm? globally?
          or do we just want a path that looks nice to a user?

          to what else can this be applied? any type of object?
          an object reference?
          can this be combined with a more complex path class, that
          would also allow estimation of (different metrics of) cost?
          maybe an object reference can contain multiple paths and the client can select
          which one it wants to use.
          (e.g. the same file may be reachable via bluetooth but also via USB)
        </summary>
      </method>
      <method name="GetName" ret="string">
        <summary>
          Returns the name of the file or folder.
          Returns null if the name is not available.
        </summary>
      </method>
      <method name="SetName">
        <summary>
          Renames the file or folder.
          Caution should be taken when allowing this: it may be possible to misuse this to query the existance of files in the parent folder.
          todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
        </summary>
        <param name="name" type="string" />
      </method>
      <method name="GetTimes" ret="FileTimes">
        <summary>
          Returns various times about the file.
        </summary>
      </method>
      <method name="SetTimes">
        <summary>
          Updates the time fields of this file.
        </summary>
        <param name="times" type="FileTimes" />
      </method>
      <method name="GetSize" ret="Maybe[long]">
        <summary>
          Returns the total size of the file or folder in bytes.
          For folders the size is determined recursively.
          Returns null if the size value is not available.
        </summary>
      </method>
      <method name="GetSizeOnDisk" ret="Maybe[long]">
        <summary>
          Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
          For folders the size is determined recursively.
          When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
          Returns null if the size cannot be determined.
        </summary>
      </method>
      <method name="Delete">
        <summary>
          Deletes the file or folder.
          todo: change semantics of this to be insecure,
          make a separate SecureDelete(int passes) method
        </summary>
        <param name="mode" type="DeleteMode" />
      </method>
      <method name="SecureDelete">
        <summary>
          Deletes the file or folder securely.
          The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
          The associated disk space must at least include file content, times, names and size.
          A solid implementation would scramble the entire file record and any logs where this file may occur.
          This method must not return until the operation is committed to disk.
          Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
        </summary>
        <param name="passes" type="int" summary="On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply." />
      </method>
    </interface>

    <interface name="Folder" inherits="FileSystemObject">
      <summary>
        Exposes a container of file system object (i.e. files and folders).
      </summary>
      <method name="GetChildren" ret="Enumerable[FileSystemObject]">
        <summary>
          Returns the list of files and folders that are direct children of this folder.
          The caller can check for each item, which interface it implements to distinguish between files and folders.
          The list is not required to be in any particular order.
        </summary>
      </method>
      <method name="GetChild" ret="FileSystemObject">
        <summary>
          Returns the file or folder with the specified name.
        </summary>
        <param name="name" type="string" summary="the name of the child" />
        <param name="file" type="bool" summary="todo: remove this arg" />
        <param name="mode" type="OpenMode" summary="the policy to use when retrieving the child" />
      </method>
      <method name="ChildExists" ret="bool">
        <summary>
          Indicates whether this folder has a direct child with the specified name.
        </summary>
        <param name="name" type="string" summary="the name of the child" />
        <param name="file" type="bool" summary="todo: remove this arg" />
      </method>
    </interface>

    <interface name="File" inherits="FileSystemObject">
      <summary>
        Exposes raw read and write operations.
      </summary>
      <method name="Read">
        <summary>
          Reads data from the file.
          The method shall fail if the requested range is out of bounds.
        </summary>
        <param name="offset" type="long" />
        <param name="count" type="long" />
        <param name="buffer" type="Array[byte]" />
        <param name="bufferOffset" type="long" />
      </method>
      <method name="Write">
        <summary>
          Writes data to the file.
          The method shall fail if the requested range is out of bounds.
        </summary>
        <param name="offset" type="long" />
        <param name="count" type="long" />
        <param name="buffer" type="Array[byte]" />
        <param name="bufferOffset" type="long" />
      </method>
      <method name="ChangeSize">
        <summary>
          Changes the size of the file.
          If the new size is larger than the current size, the slack space should be initialized to 0.
        </summary>
        <param name="newSize" type="long" />
      </method>
      <method name="Flush">
        <summary>
          Flushes any cached write operations to this file to disk.
          The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
          The method must not return until the changes are committed to non-volatile storage.
        </summary>
      </method>
    </interface>
  </namespace>
</namespace>