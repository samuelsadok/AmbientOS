/*
* This file was automatically generated by T4 text template transformation.
* Don't edit this file directly, as changes will be overwritten.
* Edit the XML file instead.
*/

using System;
using System.Collections.Generic;
using AmbientOS.Utils;

namespace AmbientOS
{
    /// <summary>
    /// Contains interfaces related to the system itself, e.g applications, services and settings
    /// </summary>
    namespace Environment
    {
        /// <summary>
        /// Represents the environment in which an action is executed.
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Environment", typeof(IEnvironmentImpl), typeof(EnvironmentRef))]
        public interface IEnvironment : IObjectRef
        {
            /// <summary>
            /// todo: rework this concept
            /// what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
            /// maybe this should be combined with access to other kinds of folders (application data, ...)
            /// and the thought seems to go a similar way with storing settings
            /// </summary>
            FileSystem.IFolder GetTempFolder();
        }

        /// <summary>
        /// Represents the environment in which an action is executed.
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Environment", typeof(IEnvironmentImpl), typeof(EnvironmentRef))]
        public interface IEnvironmentImpl : IObjectImpl
        {
            IEnvironment EnvironmentRef { get; }

            /// <summary>
            /// todo: rework this concept
            /// what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
            /// maybe this should be combined with access to other kinds of folders (application data, ...)
            /// and the thought seems to go a similar way with storing settings
            /// </summary>
            FileSystem.IFolder GetTempFolder();
        }

        /// <summary>
        /// Represents the environment in which an action is executed.
        /// </summary>
        public class EnvironmentRef : ObjectRef<IEnvironmentImpl>, IEnvironment
        {
            public EnvironmentRef(IEnvironmentImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// todo: rework this concept
            /// what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
            /// maybe this should be combined with access to other kinds of folders (application data, ...)
            /// and the thought seems to go a similar way with storing settings
            /// </summary>
            FileSystem.IFolder IEnvironment.GetTempFolder()
            {
                return implementation.GetTempFolder();
            }
        }


        /// <summary>
        /// Represents an application.
        /// todo: define this interface.
        /// consider: application name, associated actions, update, ...
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Application", typeof(IApplicationImpl), typeof(ApplicationRef))]
        public interface IApplication : IObjectRef
        {
            /// <summary>
            /// Loads and initializes the application if neccessary.
            /// </summary>
            void Load(Context context);
        }

        /// <summary>
        /// Represents an application.
        /// todo: define this interface.
        /// consider: application name, associated actions, update, ...
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Application", typeof(IApplicationImpl), typeof(ApplicationRef))]
        public interface IApplicationImpl : IObjectImpl
        {
            IApplication ApplicationRef { get; }

            /// <summary>
            /// Loads and initializes the application if neccessary.
            /// </summary>
            void Load(Context context);
        }

        /// <summary>
        /// Represents an application.
        /// todo: define this interface.
        /// consider: application name, associated actions, update, ...
        /// </summary>
        public class ApplicationRef : ObjectRef<IApplicationImpl>, IApplication
        {
            public ApplicationRef(IApplicationImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Loads and initializes the application if neccessary.
            /// </summary>
            void IApplication.Load(Context context)
            {
                implementation.Load(context);
            }
        }


        /// <summary>
        /// Represents an action that can execute a verb on specific kinds of objects.
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Action", typeof(IActionImpl), typeof(ActionRef))]
        public interface IAction : IObjectRef
        {
            /// <summary>
            /// Returns the verb that this action represents.
            /// </summary>
            string GetVerb();

            /// <summary>
            /// Indicates the name of the type that this action expects as an input.
            /// </summary>
            string GetInputTypeName();

            /// <summary>
            /// Returns the type that this action expects as an input.
            /// </summary>
            Type GetInputType();

            /// <summary>
            /// Indicates the name of the type that this action returns as an output.
            /// </summary>
            string GetOutputTypeName();

            /// <summary>
            /// Returns the type that this action returns as an output.
            /// </summary>
            Type GetOutputType();

            /// <summary>
            /// Excecutes this action on the specified object.
            /// Shall return the objects that are generated by this action if any.
            /// If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
            /// </summary>
            /// <param name="obj">The object on which to execute the action</param>
            /// <param name="context">The context in which to execute the action</param>
            DynamicSet<IObjectRef> Invoke(IObjectRef obj, Context context);
        }

        /// <summary>
        /// Represents an action that can execute a verb on specific kinds of objects.
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Action", typeof(IActionImpl), typeof(ActionRef))]
        [AOSAttribute("verb", "GetVerb")]
        [AOSAttribute("input", "GetInputTypeName")]
        [AOSAttribute("output", "GetOutputTypeName")]
        public interface IActionImpl : IObjectImpl
        {
            IAction ActionRef { get; }

            /// <summary>
            /// Returns the verb that this action represents.
            /// </summary>
            string GetVerb();

            /// <summary>
            /// Indicates the name of the type that this action expects as an input.
            /// </summary>
            string GetInputTypeName();

            /// <summary>
            /// Returns the type that this action expects as an input.
            /// </summary>
            Type GetInputType();

            /// <summary>
            /// Indicates the name of the type that this action returns as an output.
            /// </summary>
            string GetOutputTypeName();

            /// <summary>
            /// Returns the type that this action returns as an output.
            /// </summary>
            Type GetOutputType();

            /// <summary>
            /// Excecutes this action on the specified object.
            /// Shall return the objects that are generated by this action if any.
            /// If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
            /// </summary>
            /// <param name="obj">The object on which to execute the action</param>
            /// <param name="context">The context in which to execute the action</param>
            DynamicSet<IObjectRef> Invoke(IObjectRef obj, Context context);
        }

        /// <summary>
        /// Represents an action that can execute a verb on specific kinds of objects.
        /// </summary>
        public class ActionRef : ObjectRef<IActionImpl>, IAction
        {
            public ActionRef(IActionImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Returns the verb that this action represents.
            /// </summary>
            string IAction.GetVerb()
            {
                return implementation.GetVerb();
            }

            /// <summary>
            /// Indicates the name of the type that this action expects as an input.
            /// </summary>
            string IAction.GetInputTypeName()
            {
                return implementation.GetInputTypeName();
            }

            /// <summary>
            /// Returns the type that this action expects as an input.
            /// </summary>
            Type IAction.GetInputType()
            {
                return implementation.GetInputType();
            }

            /// <summary>
            /// Indicates the name of the type that this action returns as an output.
            /// </summary>
            string IAction.GetOutputTypeName()
            {
                return implementation.GetOutputTypeName();
            }

            /// <summary>
            /// Returns the type that this action returns as an output.
            /// </summary>
            Type IAction.GetOutputType()
            {
                return implementation.GetOutputType();
            }

            /// <summary>
            /// Excecutes this action on the specified object.
            /// Shall return the objects that are generated by this action if any.
            /// If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
            /// </summary>
            /// <param name="obj">The object on which to execute the action</param>
            /// <param name="context">The context in which to execute the action</param>
            DynamicSet<IObjectRef> IAction.Invoke(IObjectRef obj, Context context)
            {
                return implementation.Invoke(obj, context);
            }
        }

    }

    namespace UI
    {
        /// <summary>
        /// Describes how hard to understand or use a specific option or feature is.
        /// </summary>
        public enum Level
        {
            /// <summary>
            /// This choice is easy to understand and recommended. Typically, out of multiple options, only one is the recommended one.
            /// </summary>
            Recommended,

            /// <summary>
            /// This choice is easy to understand.
            /// </summary>
            Easy,

            /// <summary>
            /// This corresponds to a negative decision, such as No, Cancel
            /// </summary>
            Escape,

            /// <summary>
            /// This choice cannot be expected to be the right choice for a basic user. It will only be offered to advanced users.
            /// </summary>
            Advanced
        }

        /// <summary>
        /// The severity of a message.
        /// Do not use high severities unneccessarily as not to annoy the user.
        /// </summary>
        public enum Severity
        {
            /// <summary>
            /// The message is an information. Such a message usually disappears after some time or may not be shown at all.
            /// </summary>
            Info,

            /// <summary>
            /// Some action the user requested succeeded. Such a message usually disappears after some time or may not be shown at all. Examples: success message
            /// </summary>
            Success,

            /// <summary>
            /// Some action the user requested could not be started or something else happened that the active user should known about. Examples: battery low
            /// </summary>
            Warning,

            /// <summary>
            /// Some action the user requested could not be completed or something else happened that the active user should known about. Examples: service crashed
            /// </summary>
            Error
        }

        /// <summary>
        /// Holds one or more localized strings that describe the same thing with different degrees of detail.
        /// </summary>
        public class Text
        {
            /// <summary>
            /// This should be short, very easy to understand and not use any technical terms.
            /// </summary>
            public string Summary;

            /// <summary>
            /// A more detailed version of the message.
            /// Can be null.
            /// </summary>
            public string Details;

            /// <summary>
            /// This should include all technical details about the message, specifically for power users and developers.
            /// Can be null.
            /// </summary>
            public string Debug;
        }

        /// <summary>
        /// Represents a possible answer by the user to a question posed to the user.
        /// </summary>
        public class Option
        {
            public Text Text;

            public Level Level;
        }

        public enum ConsoleColor
        {
            DefaultForeground,

            DefaultBackground,

            Red,

            Yellow,

            Green,

            White,

            Gray,

            DarkGray,

            Black
        }

        /// <summary>
        /// Represents a normal key (everything that is not an action key).
        /// </summary>
        public enum Key
        {
            Unknown = 0,

            ArrowUp,

            ArrowDown,

            ArrowLeft,

            ArrowRight,

            PageUp,

            PageDown,

            Home,

            End,

            Esc,

            Enter,

            Insert,

            Tab,

            Backspace,

            Space
        }

        /// <summary>
        /// Represents one or multiple modifier keys.
        /// </summary>
        public enum KeyModifiers
        {
            Control = 0x1,

            Alt = 0x2,

            Shift = 0x4
        }

        public class KeyPress
        {
            /// <summary>
            /// If Unknown, check the Char field.
            /// </summary>
            public Key Key;

            public KeyModifiers Modifiers;

            /// <summary>
            /// Holds the unicode char associated with the key press. Null if no unicode char can be assigned to the key press.
            /// </summary>
            public char? Char;
        }

        [AOSInterface("AmbientOS.UI.Console", typeof(IConsoleImpl), typeof(ConsoleRef))]
        public interface IConsole : IObjectRef
        {
            /// <summary>
            /// Prints the specified text on the console starting at the current cursor position.
            /// The cursor is advanced to the location after the text.
            /// If a character is printed below the last line, the buffer is scrolled accordingly.
            /// This function shall accept \n as a new line character.
            /// </summary>
            /// <param name="textColor">The text color (this may be ignored by some implementations).</param>
            /// <param name="backgroundColor">The background color (this may be ignored by some implementations).</param>
            void Write(string text, ConsoleColor textColor, ConsoleColor backgroundColor);

            /// <summary>
            /// Waits for a single key stroke and returns the result.
            /// Modifier keys are not recognized on their own.
            /// The pressed key is not printed to the console.
            /// </summary>
            KeyPress Read();

            /// <summary>
            /// Clears the visible console buffer.
            /// </summary>
            /// <param name="color">The background color</param>
            void Clear(ConsoleColor color);

            /// <summary>
            /// Returns the size of the console in chars.
            /// </summary>
            Vector2D<int> GetDimensions();

            /// <summary>
            /// Returns the current cursor position.
            /// </summary>
            Vector2D<int> GetCursorPosition();

            /// <summary>
            /// Sets the cursor position.
            /// (0, 0) denotes the top left corner of the buffer.
            /// </summary>
            /// <param name="position">The new cursor position</param>
            /// <param name="visible">Indicates whether the cursor should be visible</param>
            void SetCursorPosition(Vector2D<int> position, bool visible);
        }

        [AOSInterface("AmbientOS.UI.Console", typeof(IConsoleImpl), typeof(ConsoleRef))]
        public interface IConsoleImpl : IObjectImpl
        {
            IConsole ConsoleRef { get; }

            /// <summary>
            /// Prints the specified text on the console starting at the current cursor position.
            /// The cursor is advanced to the location after the text.
            /// If a character is printed below the last line, the buffer is scrolled accordingly.
            /// This function shall accept \n as a new line character.
            /// </summary>
            /// <param name="textColor">The text color (this may be ignored by some implementations).</param>
            /// <param name="backgroundColor">The background color (this may be ignored by some implementations).</param>
            void Write(string text, ConsoleColor textColor, ConsoleColor backgroundColor);

            /// <summary>
            /// Waits for a single key stroke and returns the result.
            /// Modifier keys are not recognized on their own.
            /// The pressed key is not printed to the console.
            /// </summary>
            KeyPress Read();

            /// <summary>
            /// Clears the visible console buffer.
            /// </summary>
            /// <param name="color">The background color</param>
            void Clear(ConsoleColor color);

            /// <summary>
            /// Returns the size of the console in chars.
            /// </summary>
            Vector2D<int> GetDimensions();

            /// <summary>
            /// Returns the current cursor position.
            /// </summary>
            Vector2D<int> GetCursorPosition();

            /// <summary>
            /// Sets the cursor position.
            /// (0, 0) denotes the top left corner of the buffer.
            /// </summary>
            /// <param name="position">The new cursor position</param>
            /// <param name="visible">Indicates whether the cursor should be visible</param>
            void SetCursorPosition(Vector2D<int> position, bool visible);
        }

        public class ConsoleRef : ObjectRef<IConsoleImpl>, IConsole
        {
            public ConsoleRef(IConsoleImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Prints the specified text on the console starting at the current cursor position.
            /// The cursor is advanced to the location after the text.
            /// If a character is printed below the last line, the buffer is scrolled accordingly.
            /// This function shall accept \n as a new line character.
            /// </summary>
            /// <param name="textColor">The text color (this may be ignored by some implementations).</param>
            /// <param name="backgroundColor">The background color (this may be ignored by some implementations).</param>
            void IConsole.Write(string text, ConsoleColor textColor, ConsoleColor backgroundColor)
            {
                implementation.Write(text, textColor, backgroundColor);
            }

            /// <summary>
            /// Waits for a single key stroke and returns the result.
            /// Modifier keys are not recognized on their own.
            /// The pressed key is not printed to the console.
            /// </summary>
            KeyPress IConsole.Read()
            {
                return implementation.Read();
            }

            /// <summary>
            /// Clears the visible console buffer.
            /// </summary>
            /// <param name="color">The background color</param>
            void IConsole.Clear(ConsoleColor color)
            {
                implementation.Clear(color);
            }

            /// <summary>
            /// Returns the size of the console in chars.
            /// </summary>
            Vector2D<int> IConsole.GetDimensions()
            {
                return implementation.GetDimensions();
            }

            /// <summary>
            /// Returns the current cursor position.
            /// </summary>
            Vector2D<int> IConsole.GetCursorPosition()
            {
                return implementation.GetCursorPosition();
            }

            /// <summary>
            /// Sets the cursor position.
            /// (0, 0) denotes the top left corner of the buffer.
            /// </summary>
            /// <param name="position">The new cursor position</param>
            /// <param name="visible">Indicates whether the cursor should be visible</param>
            void IConsole.SetCursorPosition(Vector2D<int> position, bool visible)
            {
                implementation.SetCursorPosition(position, visible);
            }
        }


        /// <summary>
        /// A shell is the environment in which an action is executed.
        /// A shell may be a console, a graphical user interface, a speech based
        /// interface or anything else that allows for interaction with the user.
        /// 
        /// Actually, let's refine that:
        /// A shell is just an environment for the action, that can be used by the action
        /// to interact with the platform. If, e.g. an action is executed in a console, that doesn't
        /// mean that the console is used for all user interaction. The job of figuring out the right mode of
        /// interaction is the job of the user experience service.
        /// </summary>
        [AOSInterface("AmbientOS.UI.UI", typeof(IUIImpl), typeof(UIRef))]
        public interface IUI : IObjectRef
        {
            /// <summary>
            /// Presents a message to the user and allows the user to select one out of a set of possible answers.
            /// Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
            /// If the shell makes the decision, it shall do so according to the following rules:
            /// If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
            /// If there is are recommended options, the first one shall be selected.
            /// If there is no recommended option, the first option shall be selected.
            /// </summary>
            long PresentDialog(Text message, Option[] options);

            /// <summary>
            /// Notifies the user about something, e.g. a success or error message.
            /// Depending on the setting and severity, the message may disappear after some time or not be shown at all.
            /// </summary>
            void Notify(Text message, Severity severity);
        }

        /// <summary>
        /// A shell is the environment in which an action is executed.
        /// A shell may be a console, a graphical user interface, a speech based
        /// interface or anything else that allows for interaction with the user.
        /// 
        /// Actually, let's refine that:
        /// A shell is just an environment for the action, that can be used by the action
        /// to interact with the platform. If, e.g. an action is executed in a console, that doesn't
        /// mean that the console is used for all user interaction. The job of figuring out the right mode of
        /// interaction is the job of the user experience service.
        /// </summary>
        [AOSInterface("AmbientOS.UI.UI", typeof(IUIImpl), typeof(UIRef))]
        public interface IUIImpl : IObjectImpl
        {
            IUI UIRef { get; }

            /// <summary>
            /// Presents a message to the user and allows the user to select one out of a set of possible answers.
            /// Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
            /// If the shell makes the decision, it shall do so according to the following rules:
            /// If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
            /// If there is are recommended options, the first one shall be selected.
            /// If there is no recommended option, the first option shall be selected.
            /// </summary>
            long PresentDialog(Text message, Option[] options);

            /// <summary>
            /// Notifies the user about something, e.g. a success or error message.
            /// Depending on the setting and severity, the message may disappear after some time or not be shown at all.
            /// </summary>
            void Notify(Text message, Severity severity);
        }

        /// <summary>
        /// A shell is the environment in which an action is executed.
        /// A shell may be a console, a graphical user interface, a speech based
        /// interface or anything else that allows for interaction with the user.
        /// 
        /// Actually, let's refine that:
        /// A shell is just an environment for the action, that can be used by the action
        /// to interact with the platform. If, e.g. an action is executed in a console, that doesn't
        /// mean that the console is used for all user interaction. The job of figuring out the right mode of
        /// interaction is the job of the user experience service.
        /// </summary>
        public class UIRef : ObjectRef<IUIImpl>, IUI
        {
            public UIRef(IUIImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Presents a message to the user and allows the user to select one out of a set of possible answers.
            /// Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
            /// If the shell makes the decision, it shall do so according to the following rules:
            /// If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
            /// If there is are recommended options, the first one shall be selected.
            /// If there is no recommended option, the first option shall be selected.
            /// </summary>
            long IUI.PresentDialog(Text message, Option[] options)
            {
                return implementation.PresentDialog(message, options);
            }

            /// <summary>
            /// Notifies the user about something, e.g. a success or error message.
            /// Depending on the setting and severity, the message may disappear after some time or not be shown at all.
            /// </summary>
            void IUI.Notify(Text message, Severity severity)
            {
                implementation.Notify(message, severity);
            }
        }

    }

    /// <summary>
    /// Contains interfaces related to files, file systems and disks.
    /// </summary>
    namespace FileSystem
    {
        public enum FileSystemFlags
        {
            Hidden = 0x1,

            SoftLink = 0x2,

            Sparse = 0x4,

            Compressed = 0x8,

            Encrypted = 0x10
        }

        /// <summary>
        /// Specifies the mode of creating or opening files or folders.
        /// </summary>
        public enum OpenMode
        {
            /// <summary>
            /// Request the creation of a new file or folder. If a file or folder with the same name already exists, the create method shall throw an exception.
            /// </summary>
            New = 1,

            /// <summary>
            /// Request an existing file or folder. If the specified file or folder does not exist, the create method shall throw an exception.
            /// </summary>
            Existing = 2,

            /// <summary>
            /// The file or folder is only created if it doesn't already exist, otherwise the existing one is returned.
            /// </summary>
            NewOrExisting = 3
        }

        /// <summary>
        /// Specifies the mode of file/folder deletion. If deletion is supported on a given object, at least the Permanent option must be supported.
        /// </summary>
        public enum DeleteMode
        {
            /// <summary>
            /// The file or folder is deleted quickly and the allocated disk space becomes free. This cannot be undone. Choose this option for temporary files that contain no user data or if the user explicitly requests it.
            /// </summary>
            Permanent,

            /// <summary>
            /// The file is moved to the trash associated with the containing file system and may automatically be deleted after some time period. Choose this option if the user requested the deletion.
            /// </summary>
            Trash
        }

        /// <summary>
        /// Specifies the action that is taken if a conflict arises while copying.
        /// </summary>
        public enum MergeMode
        {
            /// <summary>
            /// If a conflict arises, abort the operation
            /// </summary>
            Abort = 0x0,

            /// <summary>
            /// Override the file at the destination
            /// </summary>
            Evict = 0x1,

            /// <summary>
            /// Don't copy conflicting files
            /// </summary>
            Skip = 0x2,

            /// <summary>
            /// Keep both files and rename the file being copied
            /// </summary>
            Both = 0x3,

            /// <summary>
            /// Keep the file with the most recent modified time
            /// </summary>
            Newer = 0x4,

            /// <summary>
            /// Keep the file with the oldest modified time
            /// </summary>
            Older = 0x5,

            /// <summary>
            /// If the conflicting objects are folders, merge them recursively. This flag can be combined with any of the other options (except for Abort).
            /// </summary>
            Merge = 0x8
        }

        public class DiskInfo
        {
            /// <summary>
            /// The ID reported by the hard disk.
            /// Be careful when using this, it could be modified and non-unique, especially for virtual disks.
            /// </summary>
            public Guid ID;

            /// <summary>
            /// The total number of tracks on the disk.
            /// In most cases (i.e. for normal hard drives, SSDs, and most optical disks), this will be 1.
            /// There are however some CD's that have multiple tracks.
            /// </summary>
            public int Tracks;

            /// <summary>
            /// The total number of sectors on one track of the disk.
            /// </summary>
            public long Sectors;

            /// <summary>
            /// The maximum number of sectors the disk could be expanded to.
            /// For most real disks, this will be the same as the current sector count.
            /// </summary>
            public long MaxSectors;

            /// <summary>
            /// The number of bytes per sector.
            /// Most of the time, this will be 512, and sometimes 4096, but you should not rely on that assumption.
            /// </summary>
            public long BytesPerSector;
        }

        public class VolumeInfo
        {
            /// <summary>
            /// The ID of the volume. Volumes on a disk using the MBR partitioning scheme get an ID derived from the disk ID and volume offet.
            /// Be careful when using this, it could be modified and non-unique, especially for virtual disks.
            /// </summary>
            public Guid ID;

            /// <summary>
            /// The type of the volume, as specified in the partition table.
            /// Zero if unknown. For legacy MBR partitions, only the last byte specifies the type and the rest is zero.
            /// </summary>
            public Guid Type;

            public FileSystemFlags flags;
        }

        public class VolumeExtent : IRefCounted
        {
            /// <summary>
            /// The track of the disk on which the extent resides. In most cases this is 0, since there's mostly only one track.
            /// </summary>
            public int Track;

            /// <summary>
            /// The absolute start sector of the extent on the underlying disk.
            /// </summary>
            public long StartSector;

            /// <summary>
            /// The total number of sectors in the extent.
            /// </summary>
            public long Sectors;

            /// <summary>
            /// The maximum number of sectors this extent could be expanded to. If there is no free space on disk following the extent, this is the same as the current sector count.
            /// </summary>
            public long MaxSectors;

            /// <summary>
            /// The underlying disk.
            /// </summary>
            public IDisk Disk { get { return _Disk; } set { _Disk?.Release(); _Disk = value?.Retain(); } }
            public IDisk _Disk;

            void IRefCounted.Alloc()
            {
                _Disk.Retain();
            }

            void IRefCounted.Free()
            {
                _Disk.Release();
            }

            void IDisposable.Dispose()
            {
                this.Release();
            }
        }

        /// <summary>
        /// Contains different kinds of times associated with the file.
        /// All times should be in UTC.
        /// For reading, null values indicate that the particular value is not available.
        /// For writing, set the fields to null that shouldn't be updated.
        /// </summary>
        public class FileTimes
        {
            /// <summary>
            /// Time when the file or folder was created.
            /// AmbientOS file system drivers shall initialize this field automatically.
            /// </summary>
            public DateTime? CreatedTime;

            /// <summary>
            /// Time when the file was modified.
            /// Semantics not clearly defined for folders.
            /// AmbientOS file system drivers shall update this field automatically.
            /// </summary>
            public DateTime? ModifiedTime;

            /// <summary>
            /// Time when the file was last read.
            /// AmbientOS file system drivers shall NOT update this field automatically, hence it is of limited value.
            /// </summary>
            public DateTime? ReadTime;
        }

        public class NamingConventions
        {
            /// <summary>
            /// All characters that must not occur anywhere of a name.
            /// </summary>
            public char[] ForbiddenChars;

            /// <summary>
            /// All characters that must not occur at the beginning of a name.
            /// </summary>
            public char[] ForbiddenLeadingChars;

            /// <summary>
            /// All characters that must not occur at the end of a name.
            /// </summary>
            public char[] ForbiddenTrailingChars;

            /// <summary>
            /// All strings that must not be used as a file or folder name.
            /// </summary>
            public string[] ForbiddenNames;

            /// <summary>
            /// The maximum number of chars in the name. Set to -1 to indicate no limit.
            /// </summary>
            public long MaxNameLength;

            /// <summary>
            /// Indicates whether the file system uses case sensitive name comparision.
            /// </summary>
            public bool CaseSensitive;
        }

        [AOSInterface("AmbientOS.FileSystem.Disk", typeof(IDiskImpl), typeof(DiskRef))]
        public interface IDisk : IObjectRef
        {
            /// <summary>
            /// Returns information about the disk.
            /// </summary>
            DiskInfo GetInfo();

            /// <summary>
            /// Changes the number of sectors in the disk.
            /// This may be possible for virtual disks.
            /// This affects all tracks equally.
            /// Returns the actual size that was set. This may be different from the requested size if it's too large.
            /// </summary>
            /// <param name="sectorCount">New size in bytes.</param>
            long SetSize(long sectorCount);

            /// <summary>
            /// Reads the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to read.</param>
            void Read(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes to the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to write.</param>
            void Write(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this disk to the device.
            /// The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        [AOSInterface("AmbientOS.FileSystem.Disk", typeof(IDiskImpl), typeof(DiskRef))]
        public interface IDiskImpl : IObjectImpl
        {
            IDisk DiskRef { get; }

            /// <summary>
            /// Returns information about the disk.
            /// </summary>
            DiskInfo GetInfo();

            /// <summary>
            /// Changes the number of sectors in the disk.
            /// This may be possible for virtual disks.
            /// This affects all tracks equally.
            /// Returns the actual size that was set. This may be different from the requested size if it's too large.
            /// </summary>
            /// <param name="sectorCount">New size in bytes.</param>
            long SetSize(long sectorCount);

            /// <summary>
            /// Reads the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to read.</param>
            void Read(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes to the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to write.</param>
            void Write(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this disk to the device.
            /// The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        public class DiskRef : ObjectRef<IDiskImpl>, IDisk
        {
            public DiskRef(IDiskImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Returns information about the disk.
            /// </summary>
            DiskInfo IDisk.GetInfo()
            {
                return implementation.GetInfo();
            }

            /// <summary>
            /// Changes the number of sectors in the disk.
            /// This may be possible for virtual disks.
            /// This affects all tracks equally.
            /// Returns the actual size that was set. This may be different from the requested size if it's too large.
            /// </summary>
            /// <param name="sectorCount">New size in bytes.</param>
            long IDisk.SetSize(long sectorCount)
            {
                return implementation.SetSize(sectorCount);
            }

            /// <summary>
            /// Reads the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to read.</param>
            void IDisk.Read(int track, long offset, long count, byte[] buffer, long bufferOffset)
            {
                implementation.Read(track, offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Writes to the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to write.</param>
            void IDisk.Write(int track, long offset, long count, byte[] buffer, long bufferOffset)
            {
                implementation.Write(track, offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Flushes any cached write operations to this disk to the device.
            /// The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void IDisk.Flush()
            {
                implementation.Flush();
            }
        }


        [AOSInterface("AmbientOS.FileSystem.Volume", typeof(IVolumeImpl), typeof(VolumeRef))]
        public interface IVolume : IObjectRef
        {
            /// <summary>
            /// Returns information about the volume.
            /// </summary>
            VolumeInfo GetInfo();

            /// <summary>
            /// Returns the extents that make up this volume.
            /// In most cases, the result contains a single element.
            /// The result may be incomplete, for instance if the volume is partially virtual.
            /// </summary>
            VolumeExtent[] GetExtents();

            /// <summary>
            /// Returns size of the volume in bytes.
            /// </summary>
            long GetSize();

            /// <summary>
            /// Changes size of the volume.
            /// This may be possible on a virtual volume or if there is unused disk space following the last volume extent.
            /// Returns the actual size that was set. This may be different from the requested size if it's too large or not sector-aligned.
            /// </summary>
            /// <param name="size">New size in bytes.</param>
            long SetSize(long size);

            /// <summary>
            /// Reads data from the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this volume to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        [AOSInterface("AmbientOS.FileSystem.Volume", typeof(IVolumeImpl), typeof(VolumeRef))]
        public interface IVolumeImpl : IObjectImpl
        {
            IVolume VolumeRef { get; }

            /// <summary>
            /// Returns information about the volume.
            /// </summary>
            VolumeInfo GetInfo();

            /// <summary>
            /// Returns the extents that make up this volume.
            /// In most cases, the result contains a single element.
            /// The result may be incomplete, for instance if the volume is partially virtual.
            /// </summary>
            VolumeExtent[] GetExtents();

            /// <summary>
            /// Returns size of the volume in bytes.
            /// </summary>
            long GetSize();

            /// <summary>
            /// Changes size of the volume.
            /// This may be possible on a virtual volume or if there is unused disk space following the last volume extent.
            /// Returns the actual size that was set. This may be different from the requested size if it's too large or not sector-aligned.
            /// </summary>
            /// <param name="size">New size in bytes.</param>
            long SetSize(long size);

            /// <summary>
            /// Reads data from the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this volume to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        public class VolumeRef : ObjectRef<IVolumeImpl>, IVolume
        {
            public VolumeRef(IVolumeImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Returns information about the volume.
            /// </summary>
            VolumeInfo IVolume.GetInfo()
            {
                return implementation.GetInfo();
            }

            /// <summary>
            /// Returns the extents that make up this volume.
            /// In most cases, the result contains a single element.
            /// The result may be incomplete, for instance if the volume is partially virtual.
            /// </summary>
            VolumeExtent[] IVolume.GetExtents()
            {
                return implementation.GetExtents();
            }

            /// <summary>
            /// Returns size of the volume in bytes.
            /// </summary>
            long IVolume.GetSize()
            {
                return implementation.GetSize();
            }

            /// <summary>
            /// Changes size of the volume.
            /// This may be possible on a virtual volume or if there is unused disk space following the last volume extent.
            /// Returns the actual size that was set. This may be different from the requested size if it's too large or not sector-aligned.
            /// </summary>
            /// <param name="size">New size in bytes.</param>
            long IVolume.SetSize(long size)
            {
                return implementation.SetSize(size);
            }

            /// <summary>
            /// Reads data from the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void IVolume.Read(long offset, long count, byte[] buffer, long bufferOffset)
            {
                implementation.Read(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Writes data to the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void IVolume.Write(long offset, long count, byte[] buffer, long bufferOffset)
            {
                implementation.Write(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Flushes any cached write operations to this volume to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void IVolume.Flush()
            {
                implementation.Flush();
            }
        }


        /// <summary>
        /// Exposes a file system.
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.FileSystem", typeof(IFileSystemImpl), typeof(FileSystemRef))]
        public interface IFileSystem : IObjectRef
        {
            /// <summary>
            /// Returns the human-readable volume name.
            /// Shall return null if there is no name available.
            /// </summary>
            string GetName();

            /// <summary>
            /// Sets the volume name.
            /// </summary>
            /// <param name="file">The new volume name</param>
            void SetName(string file);

            /// <summary>
            /// Returns the naming conventions for this file system.
            /// </summary>
            NamingConventions GetNamingConventions();

            /// <summary>
            /// Returns the root folder of this file system.
            /// </summary>
            IFolder GetRoot();

            /// <summary>
            /// Returns the total size of the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetTotalSpace();

            /// <summary>
            /// Returns the free space on the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetFreeSpace();

            /// <summary>
            /// Runs a search query on the file system and returns all matching files and folders.
            /// Search query examples (todo: decide on case sensitivity):
            /// abc.txt     returns all files with the name "abc.txt"
            /// *.txt       returns all files with the .txt extension (including the file named ".txt")
            /// *a*c*       returns all files that have "a" and "c" in their name in this order
            /// /abc.txt    returns all files named "abc.txt" in the root folder
            /// /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
            /// abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
            /// projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have
            /// 
            /// todo: rethink this - implemantation probably too complicated
            /// </summary>
            /// <param name="query">The query string (see remarks).</param>
            IEnumerable<string> GetFiles(string query);

            /// <summary>
            /// Moves a file or folder within this file system.
            /// </summary>
            /// <param name="file">The file or folder being moved. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the move operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being moved.</param>
            void Move(IFileSystemObject file, IFolder destination, string newName);

            /// <summary>
            /// Copies a file or folder within this file system.
            /// Returns the object at the destination.
            /// </summary>
            /// <param name="file">The file or folder being copied. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the copy operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being copied.</param>
            /// <param name="mode">The behavior in case of conflicts</param>
            IFileSystemObject Copy(IFileSystemObject file, IFolder destination, string newName, MergeMode mode);
        }

        /// <summary>
        /// Exposes a file system.
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.FileSystem", typeof(IFileSystemImpl), typeof(FileSystemRef))]
        public interface IFileSystemImpl : IObjectImpl
        {
            IFileSystem FileSystemRef { get; }

            /// <summary>
            /// Returns the human-readable volume name.
            /// Shall return null if there is no name available.
            /// </summary>
            string GetName();

            /// <summary>
            /// Sets the volume name.
            /// </summary>
            /// <param name="file">The new volume name</param>
            void SetName(string file);

            /// <summary>
            /// Returns the naming conventions for this file system.
            /// </summary>
            NamingConventions GetNamingConventions();

            /// <summary>
            /// Returns the root folder of this file system.
            /// </summary>
            IFolder GetRoot();

            /// <summary>
            /// Returns the total size of the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetTotalSpace();

            /// <summary>
            /// Returns the free space on the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetFreeSpace();

            /// <summary>
            /// Runs a search query on the file system and returns all matching files and folders.
            /// Search query examples (todo: decide on case sensitivity):
            /// abc.txt     returns all files with the name "abc.txt"
            /// *.txt       returns all files with the .txt extension (including the file named ".txt")
            /// *a*c*       returns all files that have "a" and "c" in their name in this order
            /// /abc.txt    returns all files named "abc.txt" in the root folder
            /// /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
            /// abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
            /// projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have
            /// 
            /// todo: rethink this - implemantation probably too complicated
            /// </summary>
            /// <param name="query">The query string (see remarks).</param>
            IEnumerable<string> GetFiles(string query);

            /// <summary>
            /// Moves a file or folder within this file system.
            /// </summary>
            /// <param name="file">The file or folder being moved. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the move operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being moved.</param>
            void Move(IFileSystemObject file, IFolder destination, string newName);

            /// <summary>
            /// Copies a file or folder within this file system.
            /// Returns the object at the destination.
            /// </summary>
            /// <param name="file">The file or folder being copied. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the copy operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being copied.</param>
            /// <param name="mode">The behavior in case of conflicts</param>
            IFileSystemObject Copy(IFileSystemObject file, IFolder destination, string newName, MergeMode mode);
        }

        /// <summary>
        /// Exposes a file system.
        /// </summary>
        public class FileSystemRef : ObjectRef<IFileSystemImpl>, IFileSystem
        {
            public FileSystemRef(IFileSystemImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Returns the human-readable volume name.
            /// Shall return null if there is no name available.
            /// </summary>
            string IFileSystem.GetName()
            {
                return implementation.GetName();
            }

            /// <summary>
            /// Sets the volume name.
            /// </summary>
            /// <param name="file">The new volume name</param>
            void IFileSystem.SetName(string file)
            {
                implementation.SetName(file);
            }

            /// <summary>
            /// Returns the naming conventions for this file system.
            /// </summary>
            NamingConventions IFileSystem.GetNamingConventions()
            {
                return implementation.GetNamingConventions();
            }

            /// <summary>
            /// Returns the root folder of this file system.
            /// </summary>
            IFolder IFileSystem.GetRoot()
            {
                return implementation.GetRoot();
            }

            /// <summary>
            /// Returns the total size of the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? IFileSystem.GetTotalSpace()
            {
                return implementation.GetTotalSpace();
            }

            /// <summary>
            /// Returns the free space on the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? IFileSystem.GetFreeSpace()
            {
                return implementation.GetFreeSpace();
            }

            /// <summary>
            /// Runs a search query on the file system and returns all matching files and folders.
            /// Search query examples (todo: decide on case sensitivity):
            /// abc.txt     returns all files with the name "abc.txt"
            /// *.txt       returns all files with the .txt extension (including the file named ".txt")
            /// *a*c*       returns all files that have "a" and "c" in their name in this order
            /// /abc.txt    returns all files named "abc.txt" in the root folder
            /// /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
            /// abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
            /// projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have
            /// 
            /// todo: rethink this - implemantation probably too complicated
            /// </summary>
            /// <param name="query">The query string (see remarks).</param>
            IEnumerable<string> IFileSystem.GetFiles(string query)
            {
                return implementation.GetFiles(query);
            }

            /// <summary>
            /// Moves a file or folder within this file system.
            /// </summary>
            /// <param name="file">The file or folder being moved. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the move operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being moved.</param>
            void IFileSystem.Move(IFileSystemObject file, IFolder destination, string newName)
            {
                implementation.Move(file, destination, newName);
            }

            /// <summary>
            /// Copies a file or folder within this file system.
            /// Returns the object at the destination.
            /// </summary>
            /// <param name="file">The file or folder being copied. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the copy operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being copied.</param>
            /// <param name="mode">The behavior in case of conflicts</param>
            IFileSystemObject IFileSystem.Copy(IFileSystemObject file, IFolder destination, string newName, MergeMode mode)
            {
                return implementation.Copy(file, destination, newName, mode);
            }
        }


        [AOSInterface("AmbientOS.FileSystem.FileSystemObject", typeof(IFileSystemObjectImpl), typeof(FileSystemObjectRef))]
        public interface IFileSystemObject : IObjectRef
        {
            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem GetFileSystem();

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            string GetPath();

            /// <summary>
            /// Returns the name of the file or folder.
            /// Returns null if the name is not available.
            /// </summary>
            string GetName();

            /// <summary>
            /// Renames the file or folder.
            /// Caution should be taken when allowing this: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            void SetName(string name);

            /// <summary>
            /// Returns various times about the file.
            /// </summary>
            FileTimes GetTimes();

            /// <summary>
            /// Updates the time fields of this file.
            /// </summary>
            void SetTimes(FileTimes times);

            /// <summary>
            /// Returns the total size of the file or folder in bytes.
            /// For folders the size is determined recursively.
            /// Returns null if the size value is not available.
            /// </summary>
            long? GetSize();

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? GetSizeOnDisk();

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void Delete(DeleteMode mode);

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void SecureDelete(int passes);
        }

        [AOSInterface("AmbientOS.FileSystem.FileSystemObject", typeof(IFileSystemObjectImpl), typeof(FileSystemObjectRef))]
        [AOSAttribute("name", "GetName")]
        public interface IFileSystemObjectImpl : IObjectImpl
        {
            IFileSystemObject FileSystemObjectRef { get; }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem GetFileSystem();

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            string GetPath();

            /// <summary>
            /// Returns the name of the file or folder.
            /// Returns null if the name is not available.
            /// </summary>
            string GetName();

            /// <summary>
            /// Renames the file or folder.
            /// Caution should be taken when allowing this: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            void SetName(string name);

            /// <summary>
            /// Returns various times about the file.
            /// </summary>
            FileTimes GetTimes();

            /// <summary>
            /// Updates the time fields of this file.
            /// </summary>
            void SetTimes(FileTimes times);

            /// <summary>
            /// Returns the total size of the file or folder in bytes.
            /// For folders the size is determined recursively.
            /// Returns null if the size value is not available.
            /// </summary>
            long? GetSize();

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? GetSizeOnDisk();

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void Delete(DeleteMode mode);

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void SecureDelete(int passes);
        }

        public class FileSystemObjectRef : ObjectRef<IFileSystemObjectImpl>, IFileSystemObject
        {
            public FileSystemObjectRef(IFileSystemObjectImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem IFileSystemObject.GetFileSystem()
            {
                return implementation.GetFileSystem();
            }

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            string IFileSystemObject.GetPath()
            {
                return implementation.GetPath();
            }

            /// <summary>
            /// Returns the name of the file or folder.
            /// Returns null if the name is not available.
            /// </summary>
            string IFileSystemObject.GetName()
            {
                return implementation.GetName();
            }

            /// <summary>
            /// Renames the file or folder.
            /// Caution should be taken when allowing this: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            void IFileSystemObject.SetName(string name)
            {
                implementation.SetName(name);
            }

            /// <summary>
            /// Returns various times about the file.
            /// </summary>
            FileTimes IFileSystemObject.GetTimes()
            {
                return implementation.GetTimes();
            }

            /// <summary>
            /// Updates the time fields of this file.
            /// </summary>
            void IFileSystemObject.SetTimes(FileTimes times)
            {
                implementation.SetTimes(times);
            }

            /// <summary>
            /// Returns the total size of the file or folder in bytes.
            /// For folders the size is determined recursively.
            /// Returns null if the size value is not available.
            /// </summary>
            long? IFileSystemObject.GetSize()
            {
                return implementation.GetSize();
            }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? IFileSystemObject.GetSizeOnDisk()
            {
                return implementation.GetSizeOnDisk();
            }

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void IFileSystemObject.Delete(DeleteMode mode)
            {
                implementation.Delete(mode);
            }

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void IFileSystemObject.SecureDelete(int passes)
            {
                implementation.SecureDelete(passes);
            }
        }


        /// <summary>
        /// Exposes a container of file system object (i.e. files and folders).
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.Folder", typeof(IFolderImpl), typeof(FolderRef))]
        public interface IFolder : IObjectRef, IFileSystemObject
        {
            /// <summary>
            /// Returns the list of files and folders that are direct children of this folder.
            /// The caller can check for each item, which interface it implements to distinguish between files and folders.
            /// The list is not required to be in any particular order.
            /// </summary>
            IEnumerable<IFileSystemObject> GetChildren();

            /// <summary>
            /// Returns the file or folder with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            /// <param name="mode">the policy to use when retrieving the child</param>
            IFileSystemObject GetChild(string name, bool file, OpenMode mode);

            /// <summary>
            /// Indicates whether this folder has a direct child with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            bool ChildExists(string name, bool file);
        }

        /// <summary>
        /// Exposes a container of file system object (i.e. files and folders).
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.Folder", typeof(IFolderImpl), typeof(FolderRef))]
        public interface IFolderImpl : IObjectImpl, IFileSystemObjectImpl
        {
            IFolder FolderRef { get; }

            /// <summary>
            /// Returns the list of files and folders that are direct children of this folder.
            /// The caller can check for each item, which interface it implements to distinguish between files and folders.
            /// The list is not required to be in any particular order.
            /// </summary>
            IEnumerable<IFileSystemObject> GetChildren();

            /// <summary>
            /// Returns the file or folder with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            /// <param name="mode">the policy to use when retrieving the child</param>
            IFileSystemObject GetChild(string name, bool file, OpenMode mode);

            /// <summary>
            /// Indicates whether this folder has a direct child with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            bool ChildExists(string name, bool file);
        }

        /// <summary>
        /// Exposes a container of file system object (i.e. files and folders).
        /// </summary>
        public class FolderRef : ObjectRef<IFolderImpl>, IFolder, IFileSystemObject
        {
            IFileSystemObject FileSystemObjectRef { get; }
            public FolderRef(IFolderImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] {
                    FileSystemObjectRef = new FileSystemObjectRef(implementation)
                };
            }

            /// <summary>
            /// Returns the list of files and folders that are direct children of this folder.
            /// The caller can check for each item, which interface it implements to distinguish between files and folders.
            /// The list is not required to be in any particular order.
            /// </summary>
            IEnumerable<IFileSystemObject> IFolder.GetChildren()
            {
                return implementation.GetChildren();
            }

            /// <summary>
            /// Returns the file or folder with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            /// <param name="mode">the policy to use when retrieving the child</param>
            IFileSystemObject IFolder.GetChild(string name, bool file, OpenMode mode)
            {
                return implementation.GetChild(name, file, mode);
            }

            /// <summary>
            /// Indicates whether this folder has a direct child with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            bool IFolder.ChildExists(string name, bool file)
            {
                return implementation.ChildExists(name, file);
            }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem IFileSystemObject.GetFileSystem()
            {
                return FileSystemObjectRef.GetFileSystem();
            }

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            string IFileSystemObject.GetPath()
            {
                return FileSystemObjectRef.GetPath();
            }

            /// <summary>
            /// Returns the name of the file or folder.
            /// Returns null if the name is not available.
            /// </summary>
            string IFileSystemObject.GetName()
            {
                return FileSystemObjectRef.GetName();
            }

            /// <summary>
            /// Renames the file or folder.
            /// Caution should be taken when allowing this: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            void IFileSystemObject.SetName(string name)
            {
                FileSystemObjectRef.SetName(name);
            }

            /// <summary>
            /// Returns various times about the file.
            /// </summary>
            FileTimes IFileSystemObject.GetTimes()
            {
                return FileSystemObjectRef.GetTimes();
            }

            /// <summary>
            /// Updates the time fields of this file.
            /// </summary>
            void IFileSystemObject.SetTimes(FileTimes times)
            {
                FileSystemObjectRef.SetTimes(times);
            }

            /// <summary>
            /// Returns the total size of the file or folder in bytes.
            /// For folders the size is determined recursively.
            /// Returns null if the size value is not available.
            /// </summary>
            long? IFileSystemObject.GetSize()
            {
                return FileSystemObjectRef.GetSize();
            }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? IFileSystemObject.GetSizeOnDisk()
            {
                return FileSystemObjectRef.GetSizeOnDisk();
            }

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void IFileSystemObject.Delete(DeleteMode mode)
            {
                FileSystemObjectRef.Delete(mode);
            }

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void IFileSystemObject.SecureDelete(int passes)
            {
                FileSystemObjectRef.SecureDelete(passes);
            }
        }


        /// <summary>
        /// Exposes raw read and write operations.
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.File", typeof(IFileImpl), typeof(FileRef))]
        public interface IFile : IObjectRef, IFileSystemObject
        {
            /// <summary>
            /// Reads data from the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Changes the size of the file.
            /// If the new size is larger than the current size, the slack space should be initialized to 0.
            /// </summary>
            void ChangeSize(long newSize);

            /// <summary>
            /// Flushes any cached write operations to this file to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        /// <summary>
        /// Exposes raw read and write operations.
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.File", typeof(IFileImpl), typeof(FileRef))]
        public interface IFileImpl : IObjectImpl, IFileSystemObjectImpl
        {
            IFile FileRef { get; }

            /// <summary>
            /// Reads data from the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Changes the size of the file.
            /// If the new size is larger than the current size, the slack space should be initialized to 0.
            /// </summary>
            void ChangeSize(long newSize);

            /// <summary>
            /// Flushes any cached write operations to this file to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        /// <summary>
        /// Exposes raw read and write operations.
        /// </summary>
        public class FileRef : ObjectRef<IFileImpl>, IFile, IFileSystemObject
        {
            IFileSystemObject FileSystemObjectRef { get; }
            public FileRef(IFileImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] {
                    FileSystemObjectRef = new FileSystemObjectRef(implementation)
                };
            }

            /// <summary>
            /// Reads data from the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void IFile.Read(long offset, long count, byte[] buffer, long bufferOffset)
            {
                implementation.Read(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Writes data to the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void IFile.Write(long offset, long count, byte[] buffer, long bufferOffset)
            {
                implementation.Write(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Changes the size of the file.
            /// If the new size is larger than the current size, the slack space should be initialized to 0.
            /// </summary>
            void IFile.ChangeSize(long newSize)
            {
                implementation.ChangeSize(newSize);
            }

            /// <summary>
            /// Flushes any cached write operations to this file to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file shoud also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void IFile.Flush()
            {
                implementation.Flush();
            }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem IFileSystemObject.GetFileSystem()
            {
                return FileSystemObjectRef.GetFileSystem();
            }

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            string IFileSystemObject.GetPath()
            {
                return FileSystemObjectRef.GetPath();
            }

            /// <summary>
            /// Returns the name of the file or folder.
            /// Returns null if the name is not available.
            /// </summary>
            string IFileSystemObject.GetName()
            {
                return FileSystemObjectRef.GetName();
            }

            /// <summary>
            /// Renames the file or folder.
            /// Caution should be taken when allowing this: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            void IFileSystemObject.SetName(string name)
            {
                FileSystemObjectRef.SetName(name);
            }

            /// <summary>
            /// Returns various times about the file.
            /// </summary>
            FileTimes IFileSystemObject.GetTimes()
            {
                return FileSystemObjectRef.GetTimes();
            }

            /// <summary>
            /// Updates the time fields of this file.
            /// </summary>
            void IFileSystemObject.SetTimes(FileTimes times)
            {
                FileSystemObjectRef.SetTimes(times);
            }

            /// <summary>
            /// Returns the total size of the file or folder in bytes.
            /// For folders the size is determined recursively.
            /// Returns null if the size value is not available.
            /// </summary>
            long? IFileSystemObject.GetSize()
            {
                return FileSystemObjectRef.GetSize();
            }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? IFileSystemObject.GetSizeOnDisk()
            {
                return FileSystemObjectRef.GetSizeOnDisk();
            }

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void IFileSystemObject.Delete(DeleteMode mode)
            {
                FileSystemObjectRef.Delete(mode);
            }

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void IFileSystemObject.SecureDelete(int passes)
            {
                FileSystemObjectRef.SecureDelete(passes);
            }
        }

    }
}

