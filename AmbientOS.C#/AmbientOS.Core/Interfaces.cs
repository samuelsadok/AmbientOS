








/*
* This file was automatically generated by T4 text template transformation.
* Don't edit this file directly, as changes will be overwritten.
* Edit the XML file instead.
*/

using System;
using System.Collections.Generic;
using AmbientOS.Utils;

namespace AmbientOS
{
    /// <summary>
    /// Contains interfaces related to the system itself, e.g applications, services and settings
    /// </summary>
    namespace Environment
    {
        /// <summary>
        /// Represents the environment in which an action is executed.
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Environment", typeof(IEnvironmentImpl), typeof(EnvironmentRef))]
        public interface IEnvironment : IObjectRef
        {
            /// <summary>
            /// todo: rework this concept
            /// what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
            /// maybe this should be combined with access to other kinds of folders (application data, ...)
            /// and the thought seems to go a similar way with storing settings
            /// </summary>
            FileSystem.IFolder GetTempFolder();
        }

        [AOSInterface("AmbientOS.Environment.Environment", typeof(IEnvironmentImpl), typeof(EnvironmentRef))]
        public interface IEnvironmentImpl : IObjectImpl
        {
            IEnvironment EnvironmentRef { get; }

            /// <summary>
            /// todo: rework this concept
            /// what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
            /// maybe this should be combined with access to other kinds of folders (application data, ...)
            /// and the thought seems to go a similar way with storing settings
            /// </summary>
            FileSystem.IFolder GetTempFolder();
        }

        public class EnvironmentRef : ObjectRef<IEnvironmentImpl>, IEnvironment
        {
            public EnvironmentRef(IEnvironmentImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            protected override void DeliverPropertiesTo(IEnvironmentImpl implementation)
            {
            }
            protected override void FetchPropertiesFrom(IEnvironmentImpl implementation)
            {
            }

            /// <summary>
            /// todo: rework this concept
            /// what properties does a temp folder have? in what context does it exist (application? any object?), when will it be cleared?
            /// maybe this should be combined with access to other kinds of folders (application data, ...)
            /// and the thought seems to go a similar way with storing settings
            /// </summary>
            public FileSystem.IFolder GetTempFolder()
            {
                Barrier();
                return implementation.GetTempFolder();
            }
        }


        /// <summary>
        /// Represents an application.
        /// todo: define this interface.
        /// consider: application icon, associated actions, update, ...
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Application", typeof(IApplicationImpl), typeof(ApplicationRef))]
        public interface IApplication : IObjectRef
        {
            /// <summary>
            /// Returns a human readable name of the application.
            /// </summary>
            DynamicProperty<string> Name { get; }

            /// <summary>
            /// Returns a human readable description of the application.
            /// </summary>
            DynamicProperty<string> Description { get; }

            /// <summary>
            /// Loads and runs the application if neccessary.
            /// todo: if this is called multiple times for the same application, it should either start a new instance or resume the running instance, depending on whatever policy
            /// </summary>
            void Run(Context context);
        }

        [AOSInterface("AmbientOS.Environment.Application", typeof(IApplicationImpl), typeof(ApplicationRef))]
        public interface IApplicationImpl : IObjectImpl
        {
            IApplication ApplicationRef { get; }

            /// <summary>
            /// Returns a human readable name of the application.
            /// </summary>
            DynamicEndpoint<string> Name { get; }

            /// <summary>
            /// Returns a human readable description of the application.
            /// </summary>
            DynamicEndpoint<string> Description { get; }

            /// <summary>
            /// Loads and runs the application if neccessary.
            /// todo: if this is called multiple times for the same application, it should either start a new instance or resume the running instance, depending on whatever policy
            /// </summary>
            void Run(Context context);
        }

        public class ApplicationRef : ObjectRef<IApplicationImpl>, IApplication
        {
            public ApplicationRef(IApplicationImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IApplication_Name = new DynamicProperty<string>(communicationSignal);
                IApplication_Description = new DynamicProperty<string>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IApplicationImpl implementation)
            {
                IApplication_Name.DeliverTo(implementation.Name);
                IApplication_Description.DeliverTo(implementation.Description);
            }
            protected override void FetchPropertiesFrom(IApplicationImpl implementation)
            {
                IApplication_Name.FetchFrom(implementation.Name);
                IApplication_Description.FetchFrom(implementation.Description);
            }

            /// <summary>
            /// Returns a human readable name of the application.
            /// </summary>
            DynamicProperty<string> IApplication.Name { get { return IApplication_Name.Get(); } }
            readonly DynamicProperty<string> IApplication_Name;

            /// <summary>
            /// Returns a human readable description of the application.
            /// </summary>
            DynamicProperty<string> IApplication.Description { get { return IApplication_Description.Get(); } }
            readonly DynamicProperty<string> IApplication_Description;

            /// <summary>
            /// Loads and runs the application if neccessary.
            /// todo: if this is called multiple times for the same application, it should either start a new instance or resume the running instance, depending on whatever policy
            /// </summary>
            public void Run(Context context)
            {
                Barrier();
                implementation.Run(context);
            }
        }


        /// <summary>
        /// Represents an action that can execute a verb on specific kinds of objects.
        /// </summary>
        [AOSInterface("AmbientOS.Environment.Action", typeof(IActionImpl), typeof(ActionRef))]
        public interface IAction : IObjectRef
        {
            /// <summary>
            /// Returns the verb that this action represents.
            /// </summary>
            DynamicProperty<string> Verb { get; }

            /// <summary>
            /// Returns the type that this action expects as an input.
            /// </summary>
            DynamicProperty<Type> InputType { get; }

            /// <summary>
            /// Returns the type that this action returns as an output.
            /// </summary>
            DynamicProperty<Type> OutputType { get; }

            /// <summary>
            /// Indicates the name of the type that this action expects as an input.
            /// </summary>
            DynamicProperty<string> InputTypeName { get; }

            /// <summary>
            /// Indicates the name of the type that this action returns as an output.
            /// </summary>
            DynamicProperty<string> OutputTypeName { get; }

            /// <summary>
            /// Excecutes this action on the specified object.
            /// Shall return the objects that are generated by this action if any.
            /// If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
            /// </summary>
            /// <param name="obj">The object on which to execute the action</param>
            /// <param name="context">The context in which to execute the action</param>
            DynamicSet<IObjectRef> Invoke(IObjectRef obj, Context context);
        }

        [AOSInterface("AmbientOS.Environment.Action", typeof(IActionImpl), typeof(ActionRef))]
        public interface IActionImpl : IObjectImpl
        {
            IAction ActionRef { get; }

            /// <summary>
            /// Returns the verb that this action represents.
            /// </summary>
            DynamicEndpoint<string> Verb { get; }

            /// <summary>
            /// Returns the type that this action expects as an input.
            /// </summary>
            DynamicEndpoint<Type> InputType { get; }

            /// <summary>
            /// Returns the type that this action returns as an output.
            /// </summary>
            DynamicEndpoint<Type> OutputType { get; }

            /// <summary>
            /// Indicates the name of the type that this action expects as an input.
            /// </summary>
            DynamicEndpoint<string> InputTypeName { get; }

            /// <summary>
            /// Indicates the name of the type that this action returns as an output.
            /// </summary>
            DynamicEndpoint<string> OutputTypeName { get; }

            /// <summary>
            /// Excecutes this action on the specified object.
            /// Shall return the objects that are generated by this action if any.
            /// If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
            /// </summary>
            /// <param name="obj">The object on which to execute the action</param>
            /// <param name="context">The context in which to execute the action</param>
            DynamicSet<IObjectRef> Invoke(IObjectRef obj, Context context);
        }

        public class ActionRef : ObjectRef<IActionImpl>, IAction
        {
            public ActionRef(IActionImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IAction_Verb = new DynamicProperty<string>(communicationSignal);
                IAction_InputType = new DynamicProperty<Type>(communicationSignal);
                IAction_OutputType = new DynamicProperty<Type>(communicationSignal);
                IAction_InputTypeName = new DynamicProperty<string>(communicationSignal);
                IAction_OutputTypeName = new DynamicProperty<string>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IActionImpl implementation)
            {
                IAction_Verb.DeliverTo(implementation.Verb);
                IAction_InputType.DeliverTo(implementation.InputType);
                IAction_OutputType.DeliverTo(implementation.OutputType);
                IAction_InputTypeName.DeliverTo(implementation.InputTypeName);
                IAction_OutputTypeName.DeliverTo(implementation.OutputTypeName);
            }
            protected override void FetchPropertiesFrom(IActionImpl implementation)
            {
                IAction_Verb.FetchFrom(implementation.Verb);
                IAction_InputType.FetchFrom(implementation.InputType);
                IAction_OutputType.FetchFrom(implementation.OutputType);
                IAction_InputTypeName.FetchFrom(implementation.InputTypeName);
                IAction_OutputTypeName.FetchFrom(implementation.OutputTypeName);
            }

            /// <summary>
            /// Returns the verb that this action represents.
            /// </summary>
            DynamicProperty<string> IAction.Verb { get { return IAction_Verb.Get(); } }
            readonly DynamicProperty<string> IAction_Verb;

            /// <summary>
            /// Returns the type that this action expects as an input.
            /// </summary>
            DynamicProperty<Type> IAction.InputType { get { return IAction_InputType.Get(); } }
            readonly DynamicProperty<Type> IAction_InputType;

            /// <summary>
            /// Returns the type that this action returns as an output.
            /// </summary>
            DynamicProperty<Type> IAction.OutputType { get { return IAction_OutputType.Get(); } }
            readonly DynamicProperty<Type> IAction_OutputType;

            /// <summary>
            /// Indicates the name of the type that this action expects as an input.
            /// </summary>
            DynamicProperty<string> IAction.InputTypeName { get { return IAction_InputTypeName.Get(); } }
            readonly DynamicProperty<string> IAction_InputTypeName;

            /// <summary>
            /// Indicates the name of the type that this action returns as an output.
            /// </summary>
            DynamicProperty<string> IAction.OutputTypeName { get { return IAction_OutputTypeName.Get(); } }
            readonly DynamicProperty<string> IAction_OutputTypeName;

            /// <summary>
            /// Excecutes this action on the specified object.
            /// Shall return the objects that are generated by this action if any.
            /// If the action yields objects, it shall block until all immediately available objects are initialized and added to the dynamic set.
            /// </summary>
            /// <param name="obj">The object on which to execute the action</param>
            /// <param name="context">The context in which to execute the action</param>
            public DynamicSet<IObjectRef> Invoke(IObjectRef obj, Context context)
            {
                Barrier();
                return implementation.Invoke(obj, context);
            }
        }

    }

    namespace UI
    {
        /// <summary>
        /// Describes how hard to understand or use a specific option or feature is.
        /// </summary>
        public enum Level
        {
            /// <summary>
            /// This choice is easy to understand and recommended. Typically, out of multiple options, only one is the recommended one.
            /// </summary>
            Recommended,

            /// <summary>
            /// This choice is easy to understand.
            /// </summary>
            Easy,

            /// <summary>
            /// This corresponds to a negative decision, such as No, Cancel
            /// </summary>
            Escape,

            /// <summary>
            /// This choice cannot be expected to be the right choice for a basic user. It will only be offered to advanced users.
            /// </summary>
            Advanced
        }

        /// <summary>
        /// The severity of a message.
        /// Do not use high severities unneccessarily as not to annoy the user.
        /// </summary>
        public enum Severity
        {
            /// <summary>
            /// The message is an information. Such a message usually disappears after some time or may not be shown at all.
            /// </summary>
            Info,

            /// <summary>
            /// Some action the user requested succeeded. Such a message usually disappears after some time or may not be shown at all. Examples: success message
            /// </summary>
            Success,

            /// <summary>
            /// Some action the user requested could not be started or something else happened that the active user should known about. Examples: battery low
            /// </summary>
            Warning,

            /// <summary>
            /// Some action the user requested could not be completed or something else happened that the active user should known about. Examples: service crashed
            /// </summary>
            Error
        }

        /// <summary>
        /// Holds one or more localized strings that describe the same thing with different degrees of detail.
        /// </summary>
        public class Text
        {
            /// <summary>
            /// This should be short, very easy to understand and not use any technical terms.
            /// </summary>
            public string Summary;

            /// <summary>
            /// A more detailed version of the message.
            /// Can be null.
            /// </summary>
            public string Details;

            /// <summary>
            /// This should include all technical details about the message, specifically for power users and developers.
            /// Can be null.
            /// </summary>
            public string Debug;
        }

        /// <summary>
        /// Represents a possible answer by the user to a question posed to the user.
        /// </summary>
        public class Option
        {
            public Text Text;

            public Level Level;
        }

        public enum ConsoleColor
        {
            DefaultForeground,

            DefaultBackground,

            Red,

            Yellow,

            Green,

            White,

            Gray,

            DarkGray,

            Black
        }

        /// <summary>
        /// Represents a normal key (everything that is not an action key).
        /// </summary>
        public enum Key
        {
            Unknown = 0,

            ArrowUp,

            ArrowDown,

            ArrowLeft,

            ArrowRight,

            PageUp,

            PageDown,

            Home,

            End,

            Esc,

            Enter,

            Insert,

            Tab,

            Backspace,

            Space
        }

        /// <summary>
        /// Represents one or multiple modifier keys.
        /// </summary>
        public enum KeyModifiers
        {
            Control = 0x1,

            Alt = 0x2,

            Shift = 0x4
        }

        public class KeyPress
        {
            /// <summary>
            /// If Unknown, check the Char field.
            /// </summary>
            public Key Key;

            public KeyModifiers Modifiers;

            /// <summary>
            /// Holds the unicode char associated with the key press. Null if no unicode char can be assigned to the key press.
            /// </summary>
            public char? Char;
        }

        [AOSInterface("AmbientOS.UI.Console", typeof(IConsoleImpl), typeof(ConsoleRef))]
        public interface IConsole : IObjectRef
        {
            /// <summary>
            /// The size of the console in chars.
            /// </summary>
            DynamicProperty<Vector2D<int>> WindowSize { get; }

            /// <summary>
            /// Gets or sets the current cursor position. (0, 0) denotes the top left corner of the console.
            /// </summary>
            DynamicProperty<Vector2D<int>> CursorPosition { get; }

            /// <summary>
            /// Gets or sets the visibility of the cursor.
            /// </summary>
            DynamicProperty<bool> CursorVisibility { get; }

            /// <summary>
            /// Prints the specified text on the console starting at the current cursor position.
            /// The cursor is advanced to the location after the text.
            /// If a character is printed below the last line, the buffer is scrolled accordingly.
            /// This function shall accept \n as a new line character.
            /// 
            /// todo: differentiate between the following cases:
            /// 1. bare input/output streams (i.e. a serial communication line)
            /// 2. a simple text-based screen buffer (where we can print any char anywhere)
            /// 3. a fully controllable terminal (where we can clear the screen and scroll)
            /// case 3 can be built from case 2 or from System.Console (this works only on Windows though)
            /// </summary>
            /// <param name="textColor">The text color (this may be ignored by some implementations).</param>
            /// <param name="backgroundColor">The background color (this may be ignored by some implementations).</param>
            void Write(string text, ConsoleColor textColor, ConsoleColor backgroundColor);

            /// <summary>
            /// Waits for a single key stroke and returns the result.
            /// Modifier keys are not recognized on their own.
            /// The pressed key is not printed to the console.
            /// </summary>
            KeyPress Read(Context context);

            /// <summary>
            /// Clears the visible console buffer.
            /// </summary>
            /// <param name="color">The background color</param>
            void Clear(ConsoleColor color);

            /// <summary>
            /// Scrolls the specified number of lines up or down.
            /// This may not work on some consoles.
            /// </summary>
            /// <param name="lines">The number of lines. Positive is down, negative is up.</param>
            void Scroll(int lines);
        }

        [AOSInterface("AmbientOS.UI.Console", typeof(IConsoleImpl), typeof(ConsoleRef))]
        public interface IConsoleImpl : IObjectImpl
        {
            IConsole ConsoleRef { get; }

            /// <summary>
            /// The size of the console in chars.
            /// </summary>
            DynamicEndpoint<Vector2D<int>> WindowSize { get; }

            /// <summary>
            /// Gets or sets the current cursor position. (0, 0) denotes the top left corner of the console.
            /// </summary>
            DynamicEndpoint<Vector2D<int>> CursorPosition { get; }

            /// <summary>
            /// Gets or sets the visibility of the cursor.
            /// </summary>
            DynamicEndpoint<bool> CursorVisibility { get; }

            /// <summary>
            /// Prints the specified text on the console starting at the current cursor position.
            /// The cursor is advanced to the location after the text.
            /// If a character is printed below the last line, the buffer is scrolled accordingly.
            /// This function shall accept \n as a new line character.
            /// 
            /// todo: differentiate between the following cases:
            /// 1. bare input/output streams (i.e. a serial communication line)
            /// 2. a simple text-based screen buffer (where we can print any char anywhere)
            /// 3. a fully controllable terminal (where we can clear the screen and scroll)
            /// case 3 can be built from case 2 or from System.Console (this works only on Windows though)
            /// </summary>
            /// <param name="textColor">The text color (this may be ignored by some implementations).</param>
            /// <param name="backgroundColor">The background color (this may be ignored by some implementations).</param>
            void Write(string text, ConsoleColor textColor, ConsoleColor backgroundColor);

            /// <summary>
            /// Waits for a single key stroke and returns the result.
            /// Modifier keys are not recognized on their own.
            /// The pressed key is not printed to the console.
            /// </summary>
            KeyPress Read(Context context);

            /// <summary>
            /// Clears the visible console buffer.
            /// </summary>
            /// <param name="color">The background color</param>
            void Clear(ConsoleColor color);

            /// <summary>
            /// Scrolls the specified number of lines up or down.
            /// This may not work on some consoles.
            /// </summary>
            /// <param name="lines">The number of lines. Positive is down, negative is up.</param>
            void Scroll(int lines);
        }

        public class ConsoleRef : ObjectRef<IConsoleImpl>, IConsole
        {
            public ConsoleRef(IConsoleImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IConsole_WindowSize = new DynamicProperty<Vector2D<int>>(communicationSignal);
                IConsole_CursorPosition = new DynamicProperty<Vector2D<int>>(communicationSignal);
                IConsole_CursorVisibility = new DynamicProperty<bool>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IConsoleImpl implementation)
            {
                IConsole_WindowSize.DeliverTo(implementation.WindowSize);
                IConsole_CursorPosition.DeliverTo(implementation.CursorPosition);
                IConsole_CursorVisibility.DeliverTo(implementation.CursorVisibility);
            }
            protected override void FetchPropertiesFrom(IConsoleImpl implementation)
            {
                IConsole_WindowSize.FetchFrom(implementation.WindowSize);
                IConsole_CursorPosition.FetchFrom(implementation.CursorPosition);
                IConsole_CursorVisibility.FetchFrom(implementation.CursorVisibility);
            }

            /// <summary>
            /// The size of the console in chars.
            /// </summary>
            DynamicProperty<Vector2D<int>> IConsole.WindowSize { get { return IConsole_WindowSize.Get(); } }
            readonly DynamicProperty<Vector2D<int>> IConsole_WindowSize;

            /// <summary>
            /// Gets or sets the current cursor position. (0, 0) denotes the top left corner of the console.
            /// </summary>
            DynamicProperty<Vector2D<int>> IConsole.CursorPosition { get { return IConsole_CursorPosition.Get(); } }
            readonly DynamicProperty<Vector2D<int>> IConsole_CursorPosition;

            /// <summary>
            /// Gets or sets the visibility of the cursor.
            /// </summary>
            DynamicProperty<bool> IConsole.CursorVisibility { get { return IConsole_CursorVisibility.Get(); } }
            readonly DynamicProperty<bool> IConsole_CursorVisibility;

            /// <summary>
            /// Prints the specified text on the console starting at the current cursor position.
            /// The cursor is advanced to the location after the text.
            /// If a character is printed below the last line, the buffer is scrolled accordingly.
            /// This function shall accept \n as a new line character.
            /// 
            /// todo: differentiate between the following cases:
            /// 1. bare input/output streams (i.e. a serial communication line)
            /// 2. a simple text-based screen buffer (where we can print any char anywhere)
            /// 3. a fully controllable terminal (where we can clear the screen and scroll)
            /// case 3 can be built from case 2 or from System.Console (this works only on Windows though)
            /// </summary>
            /// <param name="textColor">The text color (this may be ignored by some implementations).</param>
            /// <param name="backgroundColor">The background color (this may be ignored by some implementations).</param>
            public void Write(string text, ConsoleColor textColor, ConsoleColor backgroundColor)
            {
                Barrier();
                implementation.Write(text, textColor, backgroundColor);
            }

            /// <summary>
            /// Waits for a single key stroke and returns the result.
            /// Modifier keys are not recognized on their own.
            /// The pressed key is not printed to the console.
            /// </summary>
            public KeyPress Read(Context context)
            {
                Barrier();
                return implementation.Read(context);
            }

            /// <summary>
            /// Clears the visible console buffer.
            /// </summary>
            /// <param name="color">The background color</param>
            public void Clear(ConsoleColor color)
            {
                Barrier();
                implementation.Clear(color);
            }

            /// <summary>
            /// Scrolls the specified number of lines up or down.
            /// This may not work on some consoles.
            /// </summary>
            /// <param name="lines">The number of lines. Positive is down, negative is up.</param>
            public void Scroll(int lines)
            {
                Barrier();
                implementation.Scroll(lines);
            }
        }


        /// <summary>
        /// A shell is the environment in which an action is executed.
        /// A shell may be a console, a graphical user interface, a speech based
        /// interface or anything else that allows for interaction with the user.
        /// 
        /// Actually, let's refine that:
        /// A shell is just an environment for the action, that can be used by the action
        /// to interact with the platform. If, e.g. an action is executed in a console, that doesn't
        /// mean that the console is used for all user interaction. The job of figuring out the right mode of
        /// interaction is the job of the user experience service.
        /// </summary>
        [AOSInterface("AmbientOS.UI.UI", typeof(IUIImpl), typeof(UIRef))]
        public interface IUI : IObjectRef
        {
            /// <summary>
            /// Presents a message to the user and allows the user to select one out of a set of possible answers.
            /// Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
            /// If the shell makes the decision, it shall do so according to the following rules:
            /// If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
            /// If there is are recommended options, the first one shall be selected.
            /// If there is no recommended option, the first option shall be selected.
            /// </summary>
            int PresentDialog(Text message, Option[] options);

            /// <summary>
            /// Notifies the user about something, e.g. a success or error message.
            /// Depending on the setting and severity, the message may disappear after some time or not be shown at all.
            /// </summary>
            void Notify(Text message, Severity severity);
        }

        [AOSInterface("AmbientOS.UI.UI", typeof(IUIImpl), typeof(UIRef))]
        public interface IUIImpl : IObjectImpl
        {
            IUI UIRef { get; }

            /// <summary>
            /// Presents a message to the user and allows the user to select one out of a set of possible answers.
            /// Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
            /// If the shell makes the decision, it shall do so according to the following rules:
            /// If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
            /// If there is are recommended options, the first one shall be selected.
            /// If there is no recommended option, the first option shall be selected.
            /// </summary>
            int PresentDialog(Text message, Option[] options);

            /// <summary>
            /// Notifies the user about something, e.g. a success or error message.
            /// Depending on the setting and severity, the message may disappear after some time or not be shown at all.
            /// </summary>
            void Notify(Text message, Severity severity);
        }

        public class UIRef : ObjectRef<IUIImpl>, IUI
        {
            public UIRef(IUIImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            protected override void DeliverPropertiesTo(IUIImpl implementation)
            {
            }
            protected override void FetchPropertiesFrom(IUIImpl implementation)
            {
            }

            /// <summary>
            /// Presents a message to the user and allows the user to select one out of a set of possible answers.
            /// Depending on the setting (e.g. if the user is absent or if the shell is not interactive), the shell may decide on its own.
            /// If the shell makes the decision, it shall do so according to the following rules:
            /// If the user has answered the same question previously in the same or similar context, the last selection shall be returned.
            /// If there is are recommended options, the first one shall be selected.
            /// If there is no recommended option, the first option shall be selected.
            /// </summary>
            public int PresentDialog(Text message, Option[] options)
            {
                Barrier();
                return implementation.PresentDialog(message, options);
            }

            /// <summary>
            /// Notifies the user about something, e.g. a success or error message.
            /// Depending on the setting and severity, the message may disappear after some time or not be shown at all.
            /// </summary>
            public void Notify(Text message, Severity severity)
            {
                Barrier();
                implementation.Notify(message, severity);
            }
        }

    }

    /// <summary>
    /// Contains interfaces related to files, file systems and disks.
    /// </summary>
    namespace FileSystem
    {
        public enum FileSystemFlags
        {
            Hidden = 0x1,

            SoftLink = 0x2,

            Sparse = 0x4,

            Compressed = 0x8,

            Encrypted = 0x10
        }

        /// <summary>
        /// Specifies the mode of creating or opening files or folders.
        /// </summary>
        public enum OpenMode
        {
            /// <summary>
            /// Request the creation of a new file or folder. If a file or folder with the same name already exists, the create method shall throw an exception.
            /// </summary>
            New = 1,

            /// <summary>
            /// Request an existing file or folder. If the specified file or folder does not exist, the create method shall throw an exception.
            /// </summary>
            Existing = 2,

            /// <summary>
            /// The file or folder is only created if it doesn't already exist, otherwise the existing one is returned.
            /// </summary>
            NewOrExisting = 3
        }

        /// <summary>
        /// Specifies the mode of file/folder deletion. If deletion is supported on a given object, at least the Permanent option must be supported.
        /// </summary>
        public enum DeleteMode
        {
            /// <summary>
            /// The file or folder is deleted quickly and the allocated disk space becomes free. This cannot be undone. Choose this option for temporary files that contain no user data or if the user explicitly requests it.
            /// </summary>
            Permanent,

            /// <summary>
            /// The file is moved to the trash associated with the containing file system and may automatically be deleted after some time period. Choose this option if the user requested the deletion.
            /// </summary>
            Trash
        }

        /// <summary>
        /// Specifies the action that is taken if a conflict arises while copying.
        /// </summary>
        public enum MergeMode
        {
            /// <summary>
            /// If a conflict arises, abort the operation
            /// </summary>
            Abort = 0x0,

            /// <summary>
            /// Override the file at the destination
            /// </summary>
            Evict = 0x1,

            /// <summary>
            /// Don't copy conflicting files
            /// </summary>
            Skip = 0x2,

            /// <summary>
            /// Keep both files and rename the file being copied
            /// </summary>
            Both = 0x3,

            /// <summary>
            /// Keep the file with the most recent modified time
            /// </summary>
            Newer = 0x4,

            /// <summary>
            /// Keep the file with the oldest modified time
            /// </summary>
            Older = 0x5,

            /// <summary>
            /// If the conflicting objects are folders, merge them recursively. This flag can be combined with any of the other options (except for Abort).
            /// </summary>
            Merge = 0x8
        }

        public class DiskInfo
        {
            /// <summary>
            /// The ID reported by the hard disk.
            /// Be careful when using this, it could be modified and non-unique, especially for virtual disks.
            /// </summary>
            public Guid ID;

            /// <summary>
            /// The total number of tracks on the disk.
            /// In most cases (i.e. for normal hard drives, SSDs, and most optical disks), this will be 1.
            /// There are however some CD's that have multiple tracks.
            /// </summary>
            public int Tracks;

            /// <summary>
            /// The total number of sectors on one track of the disk.
            /// Each track has the same number of sectors.
            /// </summary>
            public long Sectors;

            /// <summary>
            /// The maximum number of sectors the disk could be expanded to.
            /// For most real disks, this will be the same as the current sector count.
            /// </summary>
            public long MaxSectors;

            /// <summary>
            /// The number of bytes per sector.
            /// Most of the time, this will be 512, and sometimes 4096, but you should not rely on that assumption.
            /// </summary>
            public long BytesPerSector;
        }

        public class VolumeInfo
        {
            /// <summary>
            /// The ID of the volume. Volumes on a disk using the MBR partitioning scheme get an ID derived from the disk ID and volume offet.
            /// Be careful when using this, it could be modified and non-unique, especially for virtual disks.
            /// </summary>
            public Guid ID;

            /// <summary>
            /// The type of the volume, as specified in the partition table.
            /// Zero if unknown. For legacy MBR partitions, only the last byte specifies the type and the rest is zero.
            /// </summary>
            public Guid Type;

            public FileSystemFlags Flags;
        }

        public class VolumeExtent : IRefCounted
        {
            /// <summary>
            /// The track of the disk on which the extent resides. In most cases this is 0, since there's mostly only one track.
            /// </summary>
            public int Track;

            /// <summary>
            /// The absolute start sector of the extent on the underlying disk.
            /// </summary>
            public long StartSector;

            /// <summary>
            /// The total number of sectors in the extent.
            /// </summary>
            public long Sectors;

            /// <summary>
            /// The maximum number of sectors this extent could be expanded to. If there is no free space on disk following the extent, this is the same as the current sector count.
            /// </summary>
            public long MaxSectors;

            /// <summary>
            /// The underlying disk.
            /// </summary>
            public IDisk Disk { get { return _Disk; } set { _Disk?.Release(); _Disk = value?.Retain(); } }
            public IDisk _Disk;

            void IRefCounted.Alloc()
            {
                _Disk.Retain();
            }

            void IRefCounted.Free()
            {
                _Disk.Release();
            }

            void IDisposable.Dispose()
            {
                this.Release();
            }
        }

        /// <summary>
        /// Contains different kinds of times associated with the file.
        /// All times should be in UTC.
        /// For reading, null values indicate that the particular value is not available.
        /// For writing, set the fields to null that shouldn't be updated.
        /// </summary>
        public class FileTimes
        {
            /// <summary>
            /// Time when the file or folder was created.
            /// AmbientOS file system drivers shall initialize this field automatically.
            /// </summary>
            public DateTime? CreatedTime;

            /// <summary>
            /// Time when the file was modified.
            /// Semantics not clearly defined for folders.
            /// AmbientOS file system drivers shall update this field automatically.
            /// </summary>
            public DateTime? ModifiedTime;

            /// <summary>
            /// Time when the file was last read.
            /// AmbientOS file system drivers shall NOT update this field automatically, hence it is of limited value.
            /// </summary>
            public DateTime? ReadTime;
        }

        public class NamingConventions
        {
            /// <summary>
            /// All characters that must not occur anywhere of a name.
            /// </summary>
            public char[] ForbiddenChars;

            /// <summary>
            /// All characters that must not occur at the beginning of a name.
            /// </summary>
            public char[] ForbiddenLeadingChars;

            /// <summary>
            /// All characters that must not occur at the end of a name.
            /// </summary>
            public char[] ForbiddenTrailingChars;

            /// <summary>
            /// All strings that must not be used as a file or folder name.
            /// </summary>
            public string[] ForbiddenNames;

            /// <summary>
            /// The maximum number of chars in the name. Set to -1 to indicate no limit.
            /// </summary>
            public long MaxNameLength;

            /// <summary>
            /// Indicates whether the file system uses case sensitive name comparision.
            /// </summary>
            public bool CaseSensitive;
        }

        [AOSInterface("AmbientOS.FileSystem.Disk", typeof(IDiskImpl), typeof(DiskRef))]
        public interface IDisk : IObjectRef
        {
            /// <summary>
            /// Indicates information about the disk. It may be possible for virtual disks to change some of this information.
            /// </summary>
            DynamicProperty<DiskInfo> Info { get; }

            /// <summary>
            /// Reads the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to read.</param>
            void Read(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes to the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to write.</param>
            void Write(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this disk to the device.
            /// The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        [AOSInterface("AmbientOS.FileSystem.Disk", typeof(IDiskImpl), typeof(DiskRef))]
        public interface IDiskImpl : IObjectImpl
        {
            IDisk DiskRef { get; }

            /// <summary>
            /// Indicates information about the disk. It may be possible for virtual disks to change some of this information.
            /// </summary>
            DynamicEndpoint<DiskInfo> Info { get; }

            /// <summary>
            /// Reads the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to read.</param>
            void Read(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes to the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to write.</param>
            void Write(int track, long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this disk to the device.
            /// The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        public class DiskRef : ObjectRef<IDiskImpl>, IDisk
        {
            public DiskRef(IDiskImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IDisk_Info = new DynamicProperty<DiskInfo>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IDiskImpl implementation)
            {
                IDisk_Info.DeliverTo(implementation.Info);
            }
            protected override void FetchPropertiesFrom(IDiskImpl implementation)
            {
                IDisk_Info.FetchFrom(implementation.Info);
            }

            /// <summary>
            /// Indicates information about the disk. It may be possible for virtual disks to change some of this information.
            /// </summary>
            DynamicProperty<DiskInfo> IDisk.Info { get { return IDisk_Info.Get(); } }
            readonly DynamicProperty<DiskInfo> IDisk_Info;

            /// <summary>
            /// Reads the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to read.</param>
            public void Read(int track, long offset, long count, byte[] buffer, long bufferOffset)
            {
                Barrier();
                implementation.Read(track, offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Writes to the specified sectors.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            /// <param name="offset">The sector number (starting at 0).</param>
            /// <param name="count">The number of sectors to write.</param>
            public void Write(int track, long offset, long count, byte[] buffer, long bufferOffset)
            {
                Barrier();
                implementation.Write(track, offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Flushes any cached write operations to this disk to the device.
            /// The flush operation shall propagate through the stack, i.e. if this is virtual disk image, the underlying file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            public void Flush()
            {
                Barrier();
                implementation.Flush();
            }
        }


        [AOSInterface("AmbientOS.FileSystem.Volume", typeof(IVolumeImpl), typeof(VolumeRef))]
        public interface IVolume : IObjectRef
        {
            /// <summary>
            /// Indicates information about the disk. It may be possible for some volumes to change this information.
            /// </summary>
            DynamicProperty<VolumeInfo> Info { get; }

            /// <summary>
            /// Indicates the size of the volume in bytes.
            /// It may be possible to change the size of a virtual volume or if there is unused disk space following the last volume extent.
            /// </summary>
            DynamicProperty<long> Size { get; }

            /// <summary>
            /// Returns the extents that make up this volume.
            /// In most cases, the result contains a single element.
            /// The result may be incomplete, for instance if the volume is partially virtual.
            /// </summary>
            VolumeExtent[] GetExtents();

            /// <summary>
            /// Reads data from the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this volume to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        [AOSInterface("AmbientOS.FileSystem.Volume", typeof(IVolumeImpl), typeof(VolumeRef))]
        public interface IVolumeImpl : IObjectImpl
        {
            IVolume VolumeRef { get; }

            /// <summary>
            /// Indicates information about the disk. It may be possible for some volumes to change this information.
            /// </summary>
            DynamicEndpoint<VolumeInfo> Info { get; }

            /// <summary>
            /// Indicates the size of the volume in bytes.
            /// It may be possible to change the size of a virtual volume or if there is unused disk space following the last volume extent.
            /// </summary>
            DynamicEndpoint<long> Size { get; }

            /// <summary>
            /// Returns the extents that make up this volume.
            /// In most cases, the result contains a single element.
            /// The result may be incomplete, for instance if the volume is partially virtual.
            /// </summary>
            VolumeExtent[] GetExtents();

            /// <summary>
            /// Reads data from the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this volume to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();
        }

        public class VolumeRef : ObjectRef<IVolumeImpl>, IVolume
        {
            public VolumeRef(IVolumeImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IVolume_Info = new DynamicProperty<VolumeInfo>(communicationSignal);
                IVolume_Size = new DynamicProperty<long>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IVolumeImpl implementation)
            {
                IVolume_Info.DeliverTo(implementation.Info);
                IVolume_Size.DeliverTo(implementation.Size);
            }
            protected override void FetchPropertiesFrom(IVolumeImpl implementation)
            {
                IVolume_Info.FetchFrom(implementation.Info);
                IVolume_Size.FetchFrom(implementation.Size);
            }

            /// <summary>
            /// Indicates information about the disk. It may be possible for some volumes to change this information.
            /// </summary>
            DynamicProperty<VolumeInfo> IVolume.Info { get { return IVolume_Info.Get(); } }
            readonly DynamicProperty<VolumeInfo> IVolume_Info;

            /// <summary>
            /// Indicates the size of the volume in bytes.
            /// It may be possible to change the size of a virtual volume or if there is unused disk space following the last volume extent.
            /// </summary>
            DynamicProperty<long> IVolume.Size { get { return IVolume_Size.Get(); } }
            readonly DynamicProperty<long> IVolume_Size;

            /// <summary>
            /// Returns the extents that make up this volume.
            /// In most cases, the result contains a single element.
            /// The result may be incomplete, for instance if the volume is partially virtual.
            /// </summary>
            public VolumeExtent[] GetExtents()
            {
                Barrier();
                return implementation.GetExtents();
            }

            /// <summary>
            /// Reads data from the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            public void Read(long offset, long count, byte[] buffer, long bufferOffset)
            {
                Barrier();
                implementation.Read(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Writes data to the volume.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            public void Write(long offset, long count, byte[] buffer, long bufferOffset)
            {
                Barrier();
                implementation.Write(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Flushes any cached write operations to this volume to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            public void Flush()
            {
                Barrier();
                implementation.Flush();
            }
        }


        /// <summary>
        /// Exposes a file system.
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.FileSystem", typeof(IFileSystemImpl), typeof(FileSystemRef))]
        public interface IFileSystem : IObjectRef
        {
            /// <summary>
            /// Gets or sets the human-readable volume name. Returns null if there is no name available.
            /// </summary>
            DynamicProperty<string> Name { get; }

            /// <summary>
            /// Returns the naming conventions for this file system.
            /// </summary>
            NamingConventions GetNamingConventions();

            /// <summary>
            /// Returns the root folder of this file system.
            /// </summary>
            IFolder GetRoot();

            /// <summary>
            /// Returns the total size of the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetTotalSpace();

            /// <summary>
            /// Returns the free space on the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetFreeSpace();

            /// <summary>
            /// Runs a search query on the file system and returns all matching files and folders.
            /// Search query examples (todo: decide on case sensitivity):
            /// abc.txt     returns all files with the name "abc.txt"
            /// *.txt       returns all files with the .txt extension (including the file named ".txt")
            /// *a*c*       returns all files that have "a" and "c" in their name in this order
            /// /abc.txt    returns all files named "abc.txt" in the root folder
            /// /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
            /// abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
            /// projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have
            /// 
            /// todo: rethink this - implemantation probably too complicated
            /// </summary>
            /// <param name="query">The query string (see remarks).</param>
            IEnumerable<string> GetFiles(string query);

            /// <summary>
            /// Moves a file or folder within this file system.
            /// </summary>
            /// <param name="file">The file or folder being moved. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the move operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being moved.</param>
            void Move(IFileSystemObject file, IFolder destination, string newName);

            /// <summary>
            /// Copies a file or folder within this file system.
            /// Returns the object at the destination.
            /// </summary>
            /// <param name="file">The file or folder being copied. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the copy operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being copied.</param>
            /// <param name="mode">The behavior in case of conflicts</param>
            IFileSystemObject Copy(IFileSystemObject file, IFolder destination, string newName, MergeMode mode);
        }

        [AOSInterface("AmbientOS.FileSystem.FileSystem", typeof(IFileSystemImpl), typeof(FileSystemRef))]
        public interface IFileSystemImpl : IObjectImpl
        {
            IFileSystem FileSystemRef { get; }

            /// <summary>
            /// Gets or sets the human-readable volume name. Returns null if there is no name available.
            /// </summary>
            DynamicEndpoint<string> Name { get; }

            /// <summary>
            /// Returns the naming conventions for this file system.
            /// </summary>
            NamingConventions GetNamingConventions();

            /// <summary>
            /// Returns the root folder of this file system.
            /// </summary>
            IFolder GetRoot();

            /// <summary>
            /// Returns the total size of the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetTotalSpace();

            /// <summary>
            /// Returns the free space on the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            long? GetFreeSpace();

            /// <summary>
            /// Runs a search query on the file system and returns all matching files and folders.
            /// Search query examples (todo: decide on case sensitivity):
            /// abc.txt     returns all files with the name "abc.txt"
            /// *.txt       returns all files with the .txt extension (including the file named ".txt")
            /// *a*c*       returns all files that have "a" and "c" in their name in this order
            /// /abc.txt    returns all files named "abc.txt" in the root folder
            /// /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
            /// abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
            /// projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have
            /// 
            /// todo: rethink this - implemantation probably too complicated
            /// </summary>
            /// <param name="query">The query string (see remarks).</param>
            IEnumerable<string> GetFiles(string query);

            /// <summary>
            /// Moves a file or folder within this file system.
            /// </summary>
            /// <param name="file">The file or folder being moved. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the move operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being moved.</param>
            void Move(IFileSystemObject file, IFolder destination, string newName);

            /// <summary>
            /// Copies a file or folder within this file system.
            /// Returns the object at the destination.
            /// </summary>
            /// <param name="file">The file or folder being copied. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the copy operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being copied.</param>
            /// <param name="mode">The behavior in case of conflicts</param>
            IFileSystemObject Copy(IFileSystemObject file, IFolder destination, string newName, MergeMode mode);
        }

        public class FileSystemRef : ObjectRef<IFileSystemImpl>, IFileSystem
        {
            public FileSystemRef(IFileSystemImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IFileSystem_Name = new DynamicProperty<string>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IFileSystemImpl implementation)
            {
                IFileSystem_Name.DeliverTo(implementation.Name);
            }
            protected override void FetchPropertiesFrom(IFileSystemImpl implementation)
            {
                IFileSystem_Name.FetchFrom(implementation.Name);
            }

            /// <summary>
            /// Gets or sets the human-readable volume name. Returns null if there is no name available.
            /// </summary>
            DynamicProperty<string> IFileSystem.Name { get { return IFileSystem_Name.Get(); } }
            readonly DynamicProperty<string> IFileSystem_Name;

            /// <summary>
            /// Returns the naming conventions for this file system.
            /// </summary>
            public NamingConventions GetNamingConventions()
            {
                Barrier();
                return implementation.GetNamingConventions();
            }

            /// <summary>
            /// Returns the root folder of this file system.
            /// </summary>
            public IFolder GetRoot()
            {
                Barrier();
                return implementation.GetRoot();
            }

            /// <summary>
            /// Returns the total size of the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            public long? GetTotalSpace()
            {
                Barrier();
                return implementation.GetTotalSpace();
            }

            /// <summary>
            /// Returns the free space on the volume in bytes.
            /// Shall return null if this is not applicable.
            /// </summary>
            public long? GetFreeSpace()
            {
                Barrier();
                return implementation.GetFreeSpace();
            }

            /// <summary>
            /// Runs a search query on the file system and returns all matching files and folders.
            /// Search query examples (todo: decide on case sensitivity):
            /// abc.txt     returns all files with the name "abc.txt"
            /// *.txt       returns all files with the .txt extension (including the file named ".txt")
            /// *a*c*       returns all files that have "a" and "c" in their name in this order
            /// /abc.txt    returns all files named "abc.txt" in the root folder
            /// /*/abc.txt  returns all files named "abc.txt" in any direct subfolder of the root folder
            /// abc/**/def.txt returns all files named "def.txt" in any subfolder of a folder named "def.txt"
            /// projects/*/build/**/*.exe   returns all exe files that are at some point contained in a "build" folder that have
            /// 
            /// todo: rethink this - implemantation probably too complicated
            /// </summary>
            /// <param name="query">The query string (see remarks).</param>
            public IEnumerable<string> GetFiles(string query)
            {
                Barrier();
                return implementation.GetFiles(query);
            }

            /// <summary>
            /// Moves a file or folder within this file system.
            /// </summary>
            /// <param name="file">The file or folder being moved. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the move operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being moved.</param>
            public void Move(IFileSystemObject file, IFolder destination, string newName)
            {
                Barrier();
                implementation.Move(file, destination, newName);
            }

            /// <summary>
            /// Copies a file or folder within this file system.
            /// Returns the object at the destination.
            /// </summary>
            /// <param name="file">The file or folder being copied. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="destination">The destination of the copy operation. If this doesn't belong to this file system, the method shall fail.</param>
            /// <param name="newName">The new name of the file or folder being copied.</param>
            /// <param name="mode">The behavior in case of conflicts</param>
            public IFileSystemObject Copy(IFileSystemObject file, IFolder destination, string newName, MergeMode mode)
            {
                Barrier();
                return implementation.Copy(file, destination, newName, mode);
            }
        }


        [AOSInterface("AmbientOS.FileSystem.FileSystemObject", typeof(IFileSystemObjectImpl), typeof(FileSystemObjectRef))]
        public interface IFileSystemObject : IObjectRef
        {
            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            DynamicProperty<string> Name { get; }

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            DynamicProperty<string> Path { get; }

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>
            DynamicProperty<FileTimes> Times { get; }

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>
            DynamicProperty<long?> Size { get; }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? GetSizeOnDisk();

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem GetFileSystem();

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void Delete(DeleteMode mode);

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void SecureDelete(int passes);
        }

        [AOSInterface("AmbientOS.FileSystem.FileSystemObject", typeof(IFileSystemObjectImpl), typeof(FileSystemObjectRef))]
        public interface IFileSystemObjectImpl : IObjectImpl
        {
            IFileSystemObject FileSystemObjectRef { get; }

            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            DynamicEndpoint<string> Name { get; }

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            DynamicEndpoint<string> Path { get; }

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>
            DynamicEndpoint<FileTimes> Times { get; }

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>
            DynamicEndpoint<long?> Size { get; }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            long? GetSizeOnDisk();

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            IFileSystem GetFileSystem();

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            void Delete(DeleteMode mode);

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            void SecureDelete(int passes);
        }

        public class FileSystemObjectRef : ObjectRef<IFileSystemObjectImpl>, IFileSystemObject
        {
            public FileSystemObjectRef(IFileSystemObjectImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
                IFileSystemObject_Name = new DynamicProperty<string>(communicationSignal);
                IFileSystemObject_Path = new DynamicProperty<string>(communicationSignal);
                IFileSystemObject_Times = new DynamicProperty<FileTimes>(communicationSignal);
                IFileSystemObject_Size = new DynamicProperty<long?>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IFileSystemObjectImpl implementation)
            {
                IFileSystemObject_Name.DeliverTo(implementation.Name);
                IFileSystemObject_Path.DeliverTo(implementation.Path);
                IFileSystemObject_Times.DeliverTo(implementation.Times);
                IFileSystemObject_Size.DeliverTo(implementation.Size);
            }
            protected override void FetchPropertiesFrom(IFileSystemObjectImpl implementation)
            {
                IFileSystemObject_Name.FetchFrom(implementation.Name);
                IFileSystemObject_Path.FetchFrom(implementation.Path);
                IFileSystemObject_Times.FetchFrom(implementation.Times);
                IFileSystemObject_Size.FetchFrom(implementation.Size);
            }

            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            DynamicProperty<string> IFileSystemObject.Name { get { return IFileSystemObject_Name.Get(); } }
            readonly DynamicProperty<string> IFileSystemObject_Name;

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            DynamicProperty<string> IFileSystemObject.Path { get { return IFileSystemObject_Path.Get(); } }
            readonly DynamicProperty<string> IFileSystemObject_Path;

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>
            DynamicProperty<FileTimes> IFileSystemObject.Times { get { return IFileSystemObject_Times.Get(); } }
            readonly DynamicProperty<FileTimes> IFileSystemObject_Times;

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>
            DynamicProperty<long?> IFileSystemObject.Size { get { return IFileSystemObject_Size.Get(); } }
            readonly DynamicProperty<long?> IFileSystemObject_Size;

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            public long? GetSizeOnDisk()
            {
                Barrier();
                return implementation.GetSizeOnDisk();
            }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            public IFileSystem GetFileSystem()
            {
                Barrier();
                return implementation.GetFileSystem();
            }

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            public void Delete(DeleteMode mode)
            {
                Barrier();
                implementation.Delete(mode);
            }

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            public void SecureDelete(int passes)
            {
                Barrier();
                implementation.SecureDelete(passes);
            }
        }


        /// <summary>
        /// Exposes a container of file system object (i.e. files and folders).
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.Folder", typeof(IFolderImpl), typeof(FolderRef))]
        public interface IFolder : IObjectRef, IFileSystemObject
        {
            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>

            /// <summary>
            /// Returns the list of files and folders that are direct children of this folder.
            /// The caller can check for each item, which interface it implements to distinguish between files and folders.
            /// The list is not guaranteed to be in any particular order.
            /// </summary>
            IEnumerable<IFileSystemObject> GetChildren();

            /// <summary>
            /// Returns the file or folder with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            /// <param name="mode">the policy to use when retrieving the child</param>
            IFileSystemObject GetChild(string name, bool file, OpenMode mode);

            /// <summary>
            /// Indicates whether this folder has a direct child with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            bool ChildExists(string name, bool file);

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
        }

        [AOSInterface("AmbientOS.FileSystem.Folder", typeof(IFolderImpl), typeof(FolderRef))]
        public interface IFolderImpl : IObjectImpl, IFileSystemObjectImpl
        {
            IFolder FolderRef { get; }

            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>

            /// <summary>
            /// Returns the list of files and folders that are direct children of this folder.
            /// The caller can check for each item, which interface it implements to distinguish between files and folders.
            /// The list is not guaranteed to be in any particular order.
            /// </summary>
            IEnumerable<IFileSystemObject> GetChildren();

            /// <summary>
            /// Returns the file or folder with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            /// <param name="mode">the policy to use when retrieving the child</param>
            IFileSystemObject GetChild(string name, bool file, OpenMode mode);

            /// <summary>
            /// Indicates whether this folder has a direct child with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            bool ChildExists(string name, bool file);

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
        }

        public class FolderRef : ObjectRef<IFolderImpl>, IFolder, IFileSystemObject
        {
            IFileSystemObject FileSystemObjectRef { get; }
            public FolderRef(IFolderImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] {
                    FileSystemObjectRef = new FileSystemObjectRef(implementation)
                };
                IFileSystemObject_Name = new DynamicProperty<string>(communicationSignal);
                IFileSystemObject_Path = new DynamicProperty<string>(communicationSignal);
                IFileSystemObject_Times = new DynamicProperty<FileTimes>(communicationSignal);
                IFileSystemObject_Size = new DynamicProperty<long?>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IFolderImpl implementation)
            {
                IFileSystemObject_Name.DeliverTo(implementation.Name);
                IFileSystemObject_Path.DeliverTo(implementation.Path);
                IFileSystemObject_Times.DeliverTo(implementation.Times);
                IFileSystemObject_Size.DeliverTo(implementation.Size);
            }
            protected override void FetchPropertiesFrom(IFolderImpl implementation)
            {
                IFileSystemObject_Name.FetchFrom(implementation.Name);
                IFileSystemObject_Path.FetchFrom(implementation.Path);
                IFileSystemObject_Times.FetchFrom(implementation.Times);
                IFileSystemObject_Size.FetchFrom(implementation.Size);
            }

            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            DynamicProperty<string> IFileSystemObject.Name { get { return IFileSystemObject_Name.Get(); } }
            readonly DynamicProperty<string> IFileSystemObject_Name;

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            DynamicProperty<string> IFileSystemObject.Path { get { return IFileSystemObject_Path.Get(); } }
            readonly DynamicProperty<string> IFileSystemObject_Path;

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>
            DynamicProperty<FileTimes> IFileSystemObject.Times { get { return IFileSystemObject_Times.Get(); } }
            readonly DynamicProperty<FileTimes> IFileSystemObject_Times;

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>
            DynamicProperty<long?> IFileSystemObject.Size { get { return IFileSystemObject_Size.Get(); } }
            readonly DynamicProperty<long?> IFileSystemObject_Size;

            /// <summary>
            /// Returns the list of files and folders that are direct children of this folder.
            /// The caller can check for each item, which interface it implements to distinguish between files and folders.
            /// The list is not guaranteed to be in any particular order.
            /// </summary>
            public IEnumerable<IFileSystemObject> GetChildren()
            {
                Barrier();
                return implementation.GetChildren();
            }

            /// <summary>
            /// Returns the file or folder with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            /// <param name="mode">the policy to use when retrieving the child</param>
            public IFileSystemObject GetChild(string name, bool file, OpenMode mode)
            {
                Barrier();
                return implementation.GetChild(name, file, mode);
            }

            /// <summary>
            /// Indicates whether this folder has a direct child with the specified name.
            /// </summary>
            /// <param name="name">the name of the child</param>
            /// <param name="file">todo: remove this arg</param>
            public bool ChildExists(string name, bool file)
            {
                Barrier();
                return implementation.ChildExists(name, file);
            }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            public long? GetSizeOnDisk()
            {
                Barrier();
                return implementation.GetSizeOnDisk();
            }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            public IFileSystem GetFileSystem()
            {
                Barrier();
                return implementation.GetFileSystem();
            }

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            public void Delete(DeleteMode mode)
            {
                Barrier();
                implementation.Delete(mode);
            }

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            public void SecureDelete(int passes)
            {
                Barrier();
                implementation.SecureDelete(passes);
            }
        }


        /// <summary>
        /// Exposes raw read and write operations.
        /// </summary>
        [AOSInterface("AmbientOS.FileSystem.File", typeof(IFileImpl), typeof(FileRef))]
        public interface IFile : IObjectRef, IFileSystemObject
        {
            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>

            /// <summary>
            /// Reads data from the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this file to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
        }

        [AOSInterface("AmbientOS.FileSystem.File", typeof(IFileImpl), typeof(FileRef))]
        public interface IFileImpl : IObjectImpl, IFileSystemObjectImpl
        {
            IFile FileRef { get; }

            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>

            /// <summary>
            /// Reads data from the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Read(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Writes data to the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            void Write(long offset, long count, byte[] buffer, long bufferOffset);

            /// <summary>
            /// Flushes any cached write operations to this file to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            void Flush();

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
        }

        public class FileRef : ObjectRef<IFileImpl>, IFile, IFileSystemObject
        {
            IFileSystemObject FileSystemObjectRef { get; }
            public FileRef(IFileImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] {
                    FileSystemObjectRef = new FileSystemObjectRef(implementation)
                };
                IFileSystemObject_Name = new DynamicProperty<string>(communicationSignal);
                IFileSystemObject_Path = new DynamicProperty<string>(communicationSignal);
                IFileSystemObject_Times = new DynamicProperty<FileTimes>(communicationSignal);
                IFileSystemObject_Size = new DynamicProperty<long?>(communicationSignal);
            }

            protected override void DeliverPropertiesTo(IFileImpl implementation)
            {
                IFileSystemObject_Name.DeliverTo(implementation.Name);
                IFileSystemObject_Path.DeliverTo(implementation.Path);
                IFileSystemObject_Times.DeliverTo(implementation.Times);
                IFileSystemObject_Size.DeliverTo(implementation.Size);
            }
            protected override void FetchPropertiesFrom(IFileImpl implementation)
            {
                IFileSystemObject_Name.FetchFrom(implementation.Name);
                IFileSystemObject_Path.FetchFrom(implementation.Path);
                IFileSystemObject_Times.FetchFrom(implementation.Times);
                IFileSystemObject_Size.FetchFrom(implementation.Size);
            }

            /// <summary>
            /// Gets or sets the name of the file or folder.
            /// Returns null if the name is not available.
            /// Caution should be taken when allowing renaming: it may be possible to misuse this to query the existance of files in the parent folder.
            /// todo: think about what names we allow on what file systems (e.g. should we allow on NTFS names that would be invalid in windows? should this be a setting?)
            /// </summary>
            DynamicProperty<string> IFileSystemObject.Name { get { return IFileSystemObject_Name.Get(); } }
            readonly DynamicProperty<string> IFileSystemObject_Name;

            /// <summary>
            /// todo: think about what we really want
            /// do we want a path that uniquely identifies the object value?
            /// relative to what? another object reference? the current kernel realm? globally?
            /// or do we just want a path that looks nice to a user?
            /// 
            /// to what else can this be applied? any type of object?
            /// an object reference?
            /// can this be combined with a more complex path class, that
            /// would also allow estimation of (different metrics of) cost?
            /// maybe an object reference can contain multiple paths and the client can select
            /// which one it wants to use.
            /// (e.g. the same file may be reachable via bluetooth but also via USB)
            /// </summary>
            DynamicProperty<string> IFileSystemObject.Path { get { return IFileSystemObject_Path.Get(); } }
            readonly DynamicProperty<string> IFileSystemObject_Path;

            /// <summary>
            /// Gets or sets various time fields of this file.
            /// </summary>
            DynamicProperty<FileTimes> IFileSystemObject.Times { get { return IFileSystemObject_Times.Get(); } }
            readonly DynamicProperty<FileTimes> IFileSystemObject_Times;

            /// <summary>
            /// Returns the total size of the file or folder in bytes or null if the value cannot be determined.
            /// For folders the size is determined recursively.
            /// For files, the size may be altered if write access is available.
            /// If increasing the size of a file, the slack space is filled with zeros.
            /// </summary>
            DynamicProperty<long?> IFileSystemObject.Size { get { return IFileSystemObject_Size.Get(); } }
            readonly DynamicProperty<long?> IFileSystemObject_Size;

            /// <summary>
            /// Reads data from the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            public void Read(long offset, long count, byte[] buffer, long bufferOffset)
            {
                Barrier();
                implementation.Read(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Writes data to the file.
            /// The method shall fail if the requested range is out of bounds.
            /// </summary>
            public void Write(long offset, long count, byte[] buffer, long bufferOffset)
            {
                Barrier();
                implementation.Write(offset, count, buffer, bufferOffset);
            }

            /// <summary>
            /// Flushes any cached write operations to this file to disk.
            /// The flush operation shall propagate through the stack, i.e. if the underlying disk itself is a virtual disk image, that file should also be flushed.
            /// The method must not return until the changes are committed to non-volatile storage.
            /// </summary>
            public void Flush()
            {
                Barrier();
                implementation.Flush();
            }

            /// <summary>
            /// Returns the total size of the file or folder (recursive) on disk. This includes the full allocated size including the file system structures that make up this file or folder.
            /// For folders the size is determined recursively.
            /// When querying the size-on-disk of the root folder of a volume, the result should be very close to the occupied disk space.
            /// Returns null if the size cannot be determined.
            /// </summary>
            public long? GetSizeOnDisk()
            {
                Barrier();
                return implementation.GetSizeOnDisk();
            }

            /// <summary>
            /// Returns the file system that contains this file or folder.
            /// Returns null if the object does not belong to a filesystem (e.g. for a virtual folder).
            /// </summary>
            public IFileSystem GetFileSystem()
            {
                Barrier();
                return implementation.GetFileSystem();
            }

            /// <summary>
            /// Deletes the file or folder.
            /// todo: change semantics of this to be insecure,
            /// make a separate SecureDelete(int passes) method
            /// </summary>
            public void Delete(DeleteMode mode)
            {
                Barrier();
                implementation.Delete(mode);
            }

            /// <summary>
            /// Deletes the file or folder securely.
            /// The associated disk space shall be overwritten with the output of a computationally secure pseudorandom generator.
            /// The associated disk space must at least include file content, times, names and size.
            /// A solid implementation would scramble the entire file record and any logs where this file may occur.
            /// This method must not return until the operation is committed to disk.
            /// Choose this method over the normal Delete method for temporary files that may contain user data or if the user explicitly requests it.
            /// </summary>
            /// <param name="passes">On most storage devices, the old data is still recoverable after overwriting it. Multiple write passes make this harder. This specifies the number of passes to apply.</param>
            public void SecureDelete(int passes)
            {
                Barrier();
                implementation.SecureDelete(passes);
            }
        }

    }

    /// <summary>
    /// Contains interfaces related to networking and connectivity.
    /// </summary>
    namespace Net
    {
        /// <summary>
        /// A facility capable of receiving Bluetooth LE advertisments and exposing the discovered peripherals.
        /// </summary>
        [AOSInterface("AmbientOS.Net.BluetoothLEScanner", typeof(IBluetoothLEScannerImpl), typeof(BluetoothLEScannerRef))]
        public interface IBluetoothLEScanner : IObjectRef
        {
            /// <summary>
            /// Starts a scan for peripherals.
            /// The peripherals are added and removed to a dynamic set as they are discovered and lost.
            /// If the reference count of the dynamic set reaches 0, the scan is stopped. It is restarted if the set is referenced again.
            /// </summary>
            DynamicSet<IBluetoothLEPeripheral> Scan(int parameters, Context context);
        }

        [AOSInterface("AmbientOS.Net.BluetoothLEScanner", typeof(IBluetoothLEScannerImpl), typeof(BluetoothLEScannerRef))]
        public interface IBluetoothLEScannerImpl : IObjectImpl
        {
            IBluetoothLEScanner BluetoothLEScannerRef { get; }

            /// <summary>
            /// Starts a scan for peripherals.
            /// The peripherals are added and removed to a dynamic set as they are discovered and lost.
            /// If the reference count of the dynamic set reaches 0, the scan is stopped. It is restarted if the set is referenced again.
            /// </summary>
            DynamicSet<IBluetoothLEPeripheral> Scan(int parameters, Context context);
        }

        public class BluetoothLEScannerRef : ObjectRef<IBluetoothLEScannerImpl>, IBluetoothLEScanner
        {
            public BluetoothLEScannerRef(IBluetoothLEScannerImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            protected override void DeliverPropertiesTo(IBluetoothLEScannerImpl implementation)
            {
            }
            protected override void FetchPropertiesFrom(IBluetoothLEScannerImpl implementation)
            {
            }

            /// <summary>
            /// Starts a scan for peripherals.
            /// The peripherals are added and removed to a dynamic set as they are discovered and lost.
            /// If the reference count of the dynamic set reaches 0, the scan is stopped. It is restarted if the set is referenced again.
            /// </summary>
            public DynamicSet<IBluetoothLEPeripheral> Scan(int parameters, Context context)
            {
                Barrier();
                return implementation.Scan(parameters, context);
            }
        }


        [AOSInterface("AmbientOS.Net.BluetoothLEPeripheral", typeof(IBluetoothLEPeripheralImpl), typeof(BluetoothLEPeripheralRef))]
        public interface IBluetoothLEPeripheral : IObjectRef
        {
            /// <summary>
            /// Establishes a connection with the peripheral.
            /// </summary>
            void Connect();
        }

        [AOSInterface("AmbientOS.Net.BluetoothLEPeripheral", typeof(IBluetoothLEPeripheralImpl), typeof(BluetoothLEPeripheralRef))]
        public interface IBluetoothLEPeripheralImpl : IObjectImpl
        {
            IBluetoothLEPeripheral BluetoothLEPeripheralRef { get; }

            /// <summary>
            /// Establishes a connection with the peripheral.
            /// </summary>
            void Connect();
        }

        public class BluetoothLEPeripheralRef : ObjectRef<IBluetoothLEPeripheralImpl>, IBluetoothLEPeripheral
        {
            public BluetoothLEPeripheralRef(IBluetoothLEPeripheralImpl implementation)
                : base(implementation)
            {
                baseReferences = new IObjectRef[] { };
            }

            protected override void DeliverPropertiesTo(IBluetoothLEPeripheralImpl implementation)
            {
            }
            protected override void FetchPropertiesFrom(IBluetoothLEPeripheralImpl implementation)
            {
            }

            /// <summary>
            /// Establishes a connection with the peripheral.
            /// </summary>
            public void Connect()
            {
                Barrier();
                implementation.Connect();
            }
        }

    }
}

